"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[499],{44044:function(t,a,e){var n=e(48834).Buffer;Object.defineProperty(a,"__esModule",{value:!0});var i=e(38858),r=e(94574),o=e(41785),s=(e(92244),e(71941)),c=e(8228),l=e(37356),u=e(34787),d=e(86711),w=e(83669);function f(t){return t&&"object"===typeof t&&"default"in t?t:{default:t}}var p=f(o),m=f(s),g=f(d),h=f(w);r.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),r.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");const b=r.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),y=r.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function G(t){let a;if(r.Scalar.eq(t,y))a=await r.buildBn128();else{if(!r.Scalar.eq(t,b))throw new Error(`Curve not supported: ${r.Scalar.toString(t)}`);a=await r.buildBls12381()}return a}async function S(t){let a;const e=t.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(e)>=0)a=await r.buildBn128();else{if(!(["BLS12381"].indexOf(e)>=0))throw new Error(`Curve not supported: ${t}`);a=await r.buildBls12381()}return a}const _=[];for(let Wt=0;Wt<256;Wt++)_[Wt]=v(Wt,8);function v(t,a){let e=0,n=t;for(let i=0;i<a;i++)e<<=1,e|=1&n,n>>=1;return e}function F(t){return(0!==(4294901760&t)?(t&=4294901760,16):0)|(0!==(4278255360&t)?(t&=4278255360,8):0)|(0!==(4042322160&t)?(t&=4042322160,4):0)|(0!==(3435973836&t)?(t&=3435973836,2):0)|0!==(2863311530&t)}function E(t,a){const e=new DataView(t.buffer,t.byteOffset,t.byteLength);let n="";for(let i=0;i<4;i++){i>0&&(n+="\n"),n+="\t\t";for(let t=0;t<4;t++)t>0&&(n+=" "),n+=e.getUint32(16*i+4*t).toString(16).padStart(8,"0")}return a&&(n=a+"\n"+n),n}function B(t,a){if(t.byteLength!=a.byteLength)return!1;for(var e=new Int8Array(t),n=new Int8Array(a),i=0;i!=t.byteLength;i++)if(e[i]!=n[i])return!1;return!0}function x(t){const a=t.getPartialHash(),e=p.default(64);return e.setPartialHash(a),e}async function A(t,a,e,n,i){if(t.G1.isZero(a))return!1;if(t.G1.isZero(e))return!1;if(t.G2.isZero(n))return!1;if(t.G2.isZero(i))return!1;return await t.pairingEq(a,i,t.G1.neg(e),n)}async function U(t){for(;!t;)t=await window.prompt("Enter a random text. (Entropy): ","");const a=p.default(64);a.update(m.default.randomBytes(64));const e=new TextEncoder;a.update(e.encode(t));const i=n.from(a.digest()),o=[];for(let n=0;n<8;n++)o[n]=i.readUInt32BE(4*n);return new r.ChaCha(o)}function L(t,a){let e,n;a<32?(e=1<<a>>>0,n=1):(e=4294967296,n=1<<a-32>>>0);let i=t;for(let r=0;r<n;r++)for(let t=0;t<e;t++)i=m.default.createHash("sha256").update(i).digest();const o=new DataView(i.buffer,i.byteOffset,i.byteLength),s=[];for(let r=0;r<8;r++)s[r]=o.getUint32(4*r,!1);return new r.ChaCha(s)}function z(t){return t instanceof Uint8Array?t:("0x"==t.slice(0,2)&&(t=t.slice(2)),new Uint8Array(t.match(/[\da-f]{2}/gi).map((function(t){return parseInt(t,16)}))))}function R(t){return Array.prototype.map.call(t,(function(t){return("0"+(255&t).toString(16)).slice(-2)})).join("")}async function k(t,a){await i.startWriteSection(t,1),await t.writeULE32(1),await i.endWriteSection(t);const e=await G(a.q);await i.startWriteSection(t,2);const n=e.q,o=8*(Math.floor((r.Scalar.bitLength(n)-1)/64)+1),s=e.r,c=8*(Math.floor((r.Scalar.bitLength(s)-1)/64)+1);await t.writeULE32(o),await i.writeBigInt(t,n,o),await t.writeULE32(c),await i.writeBigInt(t,s,c),await t.writeULE32(a.nVars),await t.writeULE32(a.nPublic),await t.writeULE32(a.domainSize),await C(t,e,a.vk_alpha_1),await C(t,e,a.vk_beta_1),await I(t,e,a.vk_beta_2),await I(t,e,a.vk_gamma_2),await C(t,e,a.vk_delta_1),await I(t,e,a.vk_delta_2),await i.endWriteSection(t)}async function C(t,a,e){const n=new Uint8Array(2*a.G1.F.n8);a.G1.toRprLEM(n,0,e),await t.write(n)}async function I(t,a,e){const n=new Uint8Array(2*a.G2.F.n8);a.G2.toRprLEM(n,0,e),await t.write(n)}async function $(t,a,e){const n=await t.read(2*a.G1.F.n8),i=a.G1.fromRprLEM(n,0);return e?a.G1.toObject(i):i}async function T(t,a,e){const n=await t.read(2*a.G2.F.n8),i=a.G2.fromRprLEM(n,0);return e?a.G2.toObject(i):i}async function O(t,a,e){await i.startReadUniqueSection(t,a,1);const n=await t.readULE32();if(await i.endReadSection(t),1==n)return await async function(t,a,e){const n={protocol:"groth16"};await i.startReadUniqueSection(t,a,2);const r=await t.readULE32();n.n8q=r,n.q=await i.readBigInt(t,r);const o=await t.readULE32();n.n8r=o,n.r=await i.readBigInt(t,o);let s=await G(n.q);return n.nVars=await t.readULE32(),n.nPublic=await t.readULE32(),n.domainSize=await t.readULE32(),n.power=F(n.domainSize),n.vk_alpha_1=await $(t,s,e),n.vk_beta_1=await $(t,s,e),n.vk_beta_2=await T(t,s,e),n.vk_gamma_2=await T(t,s,e),n.vk_delta_1=await $(t,s,e),n.vk_delta_2=await T(t,s,e),await i.endReadSection(t),n}(t,a,e);if(2==n)return await async function(t,a,e,n){const r={protocol:"plonk"};await i.startReadUniqueSection(t,a,2);const o=await t.readULE32();r.n8q=o,r.q=await i.readBigInt(t,o);const s=await t.readULE32();r.n8r=s,r.r=await i.readBigInt(t,s);let c=await G(r.q);return r.nVars=await t.readULE32(),r.nPublic=await t.readULE32(),r.domainSize=await t.readULE32(),r.power=F(r.domainSize),r.nAdditions=await t.readULE32(),r.nConstrains=await t.readULE32(),r.k1=await t.read(s),r.k2=await t.read(s),r.Qm=await $(t,c,n),r.Ql=await $(t,c,n),r.Qr=await $(t,c,n),r.Qo=await $(t,c,n),r.Qc=await $(t,c,n),r.S1=await $(t,c,n),r.S2=await $(t,c,n),r.S3=await $(t,c,n),r.X_2=await T(t,c,n),await i.endReadSection(t),r}(t,a);throw new Error("Protocol not supported: ")}async function M(t,a,e){const n={delta:{}};n.deltaAfter=await $(t,a,e),n.delta.g1_s=await $(t,a,e),n.delta.g1_sx=await $(t,a,e),n.delta.g2_spx=await T(t,a,e),n.transcript=await t.read(64),n.type=await t.readULE32();const i=await t.readULE32(),r=t.pos;let o=0;for(;t.pos-r<i;){const a=await t.read(1);if(a[0]<=o)throw new Error("Parameters in the contribution must be sorted");if(o=a[0],1==a[0]){const a=await t.read(1),e=await t.read(a[0]);n.name=(new TextDecoder).decode(e)}else if(2==a[0]){const a=await t.read(1);n.numIterationsExp=a[0]}else{if(3!=a[0])throw new Error("Parameter not recognized");{const a=await t.read(1);n.beaconHash=await t.read(a[0])}}}if(t.pos!=r+i)throw new Error("Parametes do not match");return n}async function q(t,a,e){await i.startReadUniqueSection(t,e,10);const n={contributions:[]};n.csHash=await t.read(64);const r=await t.readULE32();for(let i=0;i<r;i++){const e=await M(t,a);n.contributions.push(e)}return await i.endReadSection(t),n}async function P(t,a,e){await C(t,a,e.deltaAfter),await C(t,a,e.delta.g1_s),await C(t,a,e.delta.g1_sx),await I(t,a,e.delta.g2_spx),await t.write(e.transcript),await t.writeULE32(e.type||0);const n=[];if(e.name){n.push(1);const t=new TextEncoder("utf-8").encode(e.name.substring(0,64));n.push(t.byteLength);for(let a=0;a<t.byteLength;a++)n.push(t[a])}if(1==e.type){n.push(2),n.push(e.numIterationsExp),n.push(3),n.push(e.beaconHash.byteLength);for(let t=0;t<e.beaconHash.byteLength;t++)n.push(e.beaconHash[t])}if(n.length>0){const a=new Uint8Array(n);await t.writeULE32(a.byteLength),await t.write(a)}else await t.writeULE32(0)}async function W(t,a,e){await i.startWriteSection(t,10),await t.write(e.csHash),await t.writeULE32(e.contributions.length);for(let n=0;n<e.contributions.length;n++)await P(t,a,e.contributions[n]);await i.endWriteSection(t)}function H(t,a,e){const n=new Uint8Array(2*a.G1.F.n8);a.G1.toRprUncompressed(n,0,e),t.update(n)}function j(t,a,e){H(t,a,e.deltaAfter),H(t,a,e.delta.g1_s),H(t,a,e.delta.g1_sx),function(t,a,e){const n=new Uint8Array(2*a.G2.F.n8);a.G2.toRprUncompressed(n,0,e),t.update(n)}(t,a,e.delta.g2_spx),t.update(e.transcript)}async function V(t,a){await i.startReadUniqueSection(t,a,1);const e=await t.readULE32(),n=await i.readBigInt(t,e),r=await t.readULE32();return await i.endReadSection(t),{n8:e,q:n,nWitness:r}}const{stringifyBigInts:N}=r.utils;async function K(t,a,e){const{fd:n,sections:o}=await i.readBinFile(a,"wtns",2,1<<25,1<<23),s=await V(n,o),{fd:c,sections:l}=await i.readBinFile(t,"zkey",2,1<<25,1<<23),u=await O(c,l);if("groth16"!=u.protocol)throw new Error("zkey file is not groth16");if(!r.Scalar.eq(u.r,s.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(s.nWitness!=u.nVars)throw new Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${s.nWitness}`);const d=await G(u.q),w=d.Fr,f=d.G1,p=d.G2,m=F(u.domainSize);e&&e.debug("Reading Wtns");const g=await i.readSection(n,o,2);e&&e.debug("Reading Coeffs");const h=await i.readSection(c,l,4);e&&e.debug("Building ABC");const[b,y,S]=await async function(t,a,e,n,i){const o=t.Fr.n8,s=12+a.n8r,c=(n.byteLength-4)/s,l=new r.BigBuffer(a.domainSize*o),u=new r.BigBuffer(a.domainSize*o),d=new r.BigBuffer(a.domainSize*o),w=[l,u];for(let r=0;r<c;r++){i&&r%1e6==0&&i.debug(`QAP AB: ${r}/${c}`);const a=n.slice(4+r*s,4+r*s+s),l=new DataView(a.buffer),u=l.getUint32(0,!0),d=l.getUint32(4,!0),f=l.getUint32(8,!0),p=a.slice(12,12+o);w[u].set(t.Fr.add(w[u].slice(d*o,d*o+o),t.Fr.mul(p,e.slice(f*o,f*o+o))),d*o)}for(let r=0;r<a.domainSize;r++)i&&r%1e6==0&&i.debug(`QAP C: ${r}/${a.domainSize}`),d.set(t.Fr.mul(l.slice(r*o,r*o+o),u.slice(r*o,r*o+o)),r*o);return[l,u,d]}(d,u,g,h,e),_=m==w.s?d.Fr.shift:d.Fr.w[m+1],v=await w.ifft(b,"","",e,"IFFT_A"),E=await w.batchApplyKey(v,w.e(1),_),B=await w.fft(E,"","",e,"FFT_A"),x=await w.ifft(y,"","",e,"IFFT_B"),A=await w.batchApplyKey(x,w.e(1),_),U=await w.fft(A,"","",e,"FFT_B"),L=await w.ifft(S,"","",e,"IFFT_C"),z=await w.batchApplyKey(L,w.e(1),_),R=await w.fft(z,"","",e,"FFT_C");e&&e.debug("Join ABC");const k=await async function(t,a,e,n,i,o){const s=1<<22,c=t.Fr.n8,l=Math.floor(e.byteLength/t.Fr.n8),u=[];for(let r=0;r<l;r+=s){o&&o.debug(`JoinABC: ${r}/${l}`);const a=Math.min(l-r,s),d=[],w=e.slice(r*c,(r+a)*c),f=n.slice(r*c,(r+a)*c),p=i.slice(r*c,(r+a)*c);d.push({cmd:"ALLOCSET",var:0,buff:w}),d.push({cmd:"ALLOCSET",var:1,buff:f}),d.push({cmd:"ALLOCSET",var:2,buff:p}),d.push({cmd:"ALLOC",var:3,len:a*c}),d.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:a},{var:3}]}),d.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:a},{var:3}]}),d.push({cmd:"GET",out:0,var:3,len:a*c}),u.push(t.tm.queueAction(d))}const d=await Promise.all(u);let w;w=e instanceof r.BigBuffer?new r.BigBuffer(e.byteLength):new Uint8Array(e.byteLength);let f=0;for(let r=0;r<d.length;r++)w.set(d[r][0],f),f+=d[r][0].byteLength;return w}(d,0,B,U,R,e);let C={};e&&e.debug("Reading A Points");const I=await i.readSection(c,l,5);C.pi_a=await d.G1.multiExpAffine(I,g,e,"multiexp A"),e&&e.debug("Reading B1 Points");const $=await i.readSection(c,l,6);let T=await d.G1.multiExpAffine($,g,e,"multiexp B1");e&&e.debug("Reading B2 Points");const M=await i.readSection(c,l,7);C.pi_b=await d.G2.multiExpAffine(M,g,e,"multiexp B2"),e&&e.debug("Reading C Points");const q=await i.readSection(c,l,8);C.pi_c=await d.G1.multiExpAffine(q,g.slice((u.nPublic+1)*d.Fr.n8),e,"multiexp C"),e&&e.debug("Reading H Points");const P=await i.readSection(c,l,9),W=await d.G1.multiExpAffine(P,k,e,"multiexp H"),H=d.Fr.random(),j=d.Fr.random();C.pi_a=f.add(C.pi_a,u.vk_alpha_1),C.pi_a=f.add(C.pi_a,f.timesFr(u.vk_delta_1,H)),C.pi_b=p.add(C.pi_b,u.vk_beta_2),C.pi_b=p.add(C.pi_b,p.timesFr(u.vk_delta_2,j)),T=f.add(T,u.vk_beta_1),T=f.add(T,f.timesFr(u.vk_delta_1,j)),C.pi_c=f.add(C.pi_c,W),C.pi_c=f.add(C.pi_c,f.timesFr(C.pi_a,j)),C.pi_c=f.add(C.pi_c,f.timesFr(T,H)),C.pi_c=f.add(C.pi_c,f.timesFr(u.vk_delta_1,w.neg(w.mul(H,j))));let K=[];for(let i=1;i<=u.nPublic;i++){const t=g.slice(i*w.n8,i*w.n8+w.n8);K.push(r.Scalar.fromRprLE(t))}return C.pi_a=f.toObject(f.toAffine(C.pi_a)),C.pi_b=p.toObject(p.toAffine(C.pi_b)),C.pi_c=f.toObject(f.toAffine(C.pi_c)),C.protocol="groth16",C.curve=d.name,await c.close(),await n.close(),C=N(C),K=N(K),{proof:C,publicSignals:K}}async function D(t,a,e,n){const o=await c.readExisting(a),s=await o.read(o.totalSize);await o.close();const u=await l.WitnessCalculatorBuilder(s),d=await u.calculateBinWitness(t),w=await i.createBinFile(e,"wtns",2,2);await async function(t,a,e){await i.startWriteSection(t,1);const n=8*(Math.floor((r.Scalar.bitLength(e)-1)/64)+1);if(await t.writeULE32(n),await i.writeBigInt(t,e,n),a.byteLength%n!=0)throw new Error("Invalid witness length");await t.writeULE32(a.byteLength/n),await i.endWriteSection(t),await i.startWriteSection(t,2),await t.write(a),await i.endWriteSection(t)}(w,d,u.prime),await w.close()}const{unstringifyBigInts:Q}=r.utils;function Z(t){let a=t.toString(16);for(;a.length<64;)a="0"+a;return a=`"0x${a}"`,a}var J=Object.freeze({__proto__:null,fullProve:async function(t,a,e,n){const i={type:"mem"};return await D(t,a,i),await K(e,i,n)},prove:K,verify:async function(t,a,e,n){t=Q(t),e=Q(e),a=Q(a);const i=await S(t.curve),o=i.G1.fromObject(t.IC[0]),s=new Uint8Array(2*i.G1.F.n8*a.length),c=new Uint8Array(i.Fr.n8*a.length);for(let h=0;h<a.length;h++){const e=i.G1.fromObject(t.IC[h+1]);s.set(e,h*i.G1.F.n8*2),r.Scalar.toRprLE(c,i.Fr.n8*h,a[h],i.Fr.n8)}let l=await i.G1.multiExpAffine(s,c);l=i.G1.add(l,o);const u=i.G1.fromObject(e.pi_a),d=i.G2.fromObject(e.pi_b),w=i.G1.fromObject(e.pi_c),f=i.G2.fromObject(t.vk_gamma_2),p=i.G2.fromObject(t.vk_delta_2),m=i.G1.fromObject(t.vk_alpha_1),g=i.G2.fromObject(t.vk_beta_2);return await i.pairingEq(i.G1.neg(u),d,l,f,w,p,m,g)?(n&&n.info("OK!"),!0):(n&&n.error("Invalid proof"),!1)},exportSolidityCallData:async function(t,a){let e,n="";for(let i=0;i<a.length;i++)""!=n&&(n+=","),n+=Z(a[i]);return e=`[${Z(t.pi_a[0])}, ${Z(t.pi_a[1])}],[[${Z(t.pi_b[0][1])}, ${Z(t.pi_b[0][0])}],[${Z(t.pi_b[1][1])}, ${Z(t.pi_b[1][0])}]],[${Z(t.pi_c[0])}, ${Z(t.pi_c[1])}],[${n}]`,e}});function X(t,a){const e=new DataView(a.buffer,a.byteOffset,a.byteLength),n=[];for(let r=0;r<8;r++)n[r]=e.getUint32(4*r);const i=new r.ChaCha(n);return t.G2.fromRng(i)}function Y(t,a,e,n,i){const r=p.default(64),o=new Uint8Array([a]);r.update(o),r.update(e);const s=t.G1.toUncompressed(n);r.update(s);const c=t.G1.toUncompressed(i);r.update(c);return X(t,r.digest())}function tt(t,a,e,n,i){return t.g1_s=a.G1.toAffine(a.G1.fromRng(i)),t.g1_sx=a.G1.toAffine(a.G1.timesFr(t.g1_s,t.prvKey)),t.g2_sp=a.G2.toAffine(Y(a,e,n,t.g1_s,t.g1_sx)),t.g2_spx=a.G2.toAffine(a.G2.timesFr(t.g2_sp,t.prvKey)),t}function at(t,a,e){const n={tau:{},alpha:{},beta:{}};return n.tau.prvKey=t.Fr.fromRng(e),n.alpha.prvKey=t.Fr.fromRng(e),n.beta.prvKey=t.Fr.fromRng(e),tt(n.tau,t,0,a,e),tt(n.alpha,t,1,a,e),tt(n.beta,t,2,a,e),n}async function et(t,a,e,n){n||(n=e),await t.writeULE32(1);const i=t.pos;await t.writeULE64(0),await t.writeULE32(8*a.F1.n64);const o=new Uint8Array(a.F1.n8);r.Scalar.toRprLE(o,0,a.q,a.F1.n8),await t.write(o),await t.writeULE32(e),await t.writeULE32(n);const s=t.pos-i-8,c=t.pos;await t.writeULE64(s,i),t.pos=c}async function nt(t,a){if(!a[1])throw new Error(t.fileName+": File has no  header");if(a[1].length>1)throw new Error(t.fileName+": File has more than one header");t.pos=a[1][0].p;const e=await t.readULE32(),n=await t.read(e),i=r.Scalar.fromRprLE(n),o=await G(i);if(8*o.F1.n64!=e)throw new Error(t.fileName+": Invalid size");const s=await t.readULE32(),c=await t.readULE32();if(t.pos-a[1][0].p!=a[1][0].size)throw new Error("Invalid PTau header size");return{curve:o,power:s,ceremonyPower:c}}function it(t,a,e,n){const i={tau:{},alpha:{},beta:{}};return i.tau.g1_s=r(),i.tau.g1_sx=r(),i.alpha.g1_s=r(),i.alpha.g1_sx=r(),i.beta.g1_s=r(),i.beta.g1_sx=r(),i.tau.g2_spx=o(),i.alpha.g2_spx=o(),i.beta.g2_spx=o(),i;function r(){let i;return i=n?e.G1.fromRprLEM(t,a):e.G1.fromRprUncompressed(t,a),a+=2*e.G1.F.n8,i}function o(){let i;return i=n?e.G2.fromRprLEM(t,a):e.G2.fromRprUncompressed(t,a),a+=2*e.G2.F.n8,i}}function rt(t,a,e,n,i){async function r(n){i?e.G1.toRprLEM(t,a,n):e.G1.toRprUncompressed(t,a,n),a+=2*e.F1.n8}async function o(n){i?e.G2.toRprLEM(t,a,n):e.G2.toRprUncompressed(t,a,n),a+=2*e.F2.n8}return r(n.tau.g1_s),r(n.tau.g1_sx),r(n.alpha.g1_s),r(n.alpha.g1_sx),r(n.beta.g1_s),r(n.beta.g1_sx),o(n.tau.g2_spx),o(n.alpha.g2_spx),o(n.beta.g2_spx),t}async function ot(t,a){const e={};e.tauG1=await c(),e.tauG2=await l(),e.alphaG1=await c(),e.betaG1=await c(),e.betaG2=await l(),e.key=await async function(t,a,e){return it(await t.read(2*a.F1.n8*6+2*a.F2.n8*3),0,a,e)}(t,a,!0),e.partialHash=await t.read(216),e.nextChallenge=await t.read(64),e.type=await t.readULE32();const n=new Uint8Array(2*a.G1.F.n8*6+2*a.G2.F.n8*3);rt(n,0,a,e.key,!1);const i=p.default(64);i.setPartialHash(e.partialHash),i.update(n),e.responseHash=i.digest();const r=await t.readULE32(),o=t.pos;let s=0;for(;t.pos-o<r;){const t=await u(1);if(t[0]<=s)throw new Error("Parameters in the contribution must be sorted");if(s=t[0],1==t[0]){const t=await u(1),a=await u(t[0]);e.name=(new TextDecoder).decode(a)}else if(2==t[0]){const t=await u(1);e.numIterationsExp=t[0]}else{if(3!=t[0])throw new Error("Parameter not recognized");{const t=await u(1);e.beaconHash=await u(t[0])}}}if(t.pos!=o+r)throw new Error("Parametes do not match");return e;async function c(){const e=await t.read(2*a.G1.F.n8);return a.G1.fromRprLEM(e)}async function l(){const e=await t.read(2*a.G2.F.n8);return a.G2.fromRprLEM(e)}async function u(a){const e=await t.read(a);return new Uint8Array(e)}}async function st(t,a,e){if(!e[7])throw new Error(t.fileName+": File has no  contributions");if(e[7][0].length>1)throw new Error(t.fileName+": File has more than one contributions section");t.pos=e[7][0].p;const n=await t.readULE32(),i=[];for(let r=0;r<n;r++){const e=await ot(t,a);e.id=r+1,i.push(e)}if(t.pos-e[7][0].p!=e[7][0].size)throw new Error("Invalid contribution section size");return i}async function ct(t,a,e){const n=new Uint8Array(2*a.F1.n8),i=new Uint8Array(2*a.F2.n8);await o(e.tauG1),await s(e.tauG2),await o(e.alphaG1),await o(e.betaG1),await s(e.betaG2),await async function(t,a,e,n){const i=new Uint8Array(2*a.F1.n8*6+2*a.F2.n8*3);rt(i,0,a,e,n),await t.write(i)}(t,a,e.key,!0),await t.write(e.partialHash),await t.write(e.nextChallenge),await t.writeULE32(e.type||0);const r=[];if(e.name){r.push(1);const t=new TextEncoder("utf-8").encode(e.name.substring(0,64));r.push(t.byteLength);for(let a=0;a<t.byteLength;a++)r.push(t[a])}if(1==e.type){r.push(2),r.push(e.numIterationsExp),r.push(3),r.push(e.beaconHash.byteLength);for(let t=0;t<e.beaconHash.byteLength;t++)r.push(e.beaconHash[t])}if(r.length>0){const a=new Uint8Array(r);await t.writeULE32(a.byteLength),await t.write(a)}else await t.writeULE32(0);async function o(e){a.G1.toRprLEM(n,0,e),await t.write(n)}async function s(e){a.G2.toRprLEM(i,0,e),await t.write(i)}}async function lt(t,a,e){await t.writeULE32(7);const n=t.pos;await t.writeULE64(0),await t.writeULE32(e.length);for(let o=0;o<e.length;o++)await ct(t,a,e[o]);const i=t.pos-n-8,r=t.pos;await t.writeULE64(i,n),t.pos=r}function ut(t,a,e){e&&e.debug("Calculating First Challenge Hash");const n=new p.default(64),i=new Uint8Array(2*t.G1.F.n8),r=new Uint8Array(2*t.G2.F.n8);let o;return t.G1.toRprUncompressed(i,0,t.G1.g),t.G2.toRprUncompressed(r,0,t.G2.g),n.update(p.default(64).digest()),o=2**a*2-1,e&&e.debug("Calculate Initial Hash: tauG1"),s(i,o),o=2**a,e&&e.debug("Calculate Initial Hash: tauG2"),s(r,o),e&&e.debug("Calculate Initial Hash: alphaTauG1"),s(i,o),e&&e.debug("Calculate Initial Hash: betaTauG1"),s(i,o),n.update(r),n.digest();function s(t,a){const i=5e5,r=Math.floor(a/i),o=a%i,s=new Uint8Array(i*t.byteLength);for(let e=0;e<i;e++)s.set(t,e*t.byteLength);for(let c=0;c<r;c++)n.update(s),e&&e.debug("Initial hash: "+c*i);for(let e=0;e<o;e++)n.update(t)}}function dt(t,a,e,n){return at(t,a,L(e,n))}const wt=A;async function ft(t,a,e,n){let i;if(1==a.type){const i=dt(t,e.nextChallenge,a.beaconHash,a.numIterationsExp);if(!t.G1.eq(a.key.tau.g1_s,i.tau.g1_s))return n&&n.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.tau.g1_sx,i.tau.g1_sx))return n&&n.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G2.eq(a.key.tau.g2_spx,i.tau.g2_spx))return n&&n.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.alpha.g1_s,i.alpha.g1_s))return n&&n.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.alpha.g1_sx,i.alpha.g1_sx))return n&&n.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G2.eq(a.key.alpha.g2_spx,i.alpha.g2_spx))return n&&n.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.beta.g1_s,i.beta.g1_s))return n&&n.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.beta.g1_sx,i.beta.g1_sx))return n&&n.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G2.eq(a.key.beta.g2_spx,i.beta.g2_spx))return n&&n.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1}return a.key.tau.g2_sp=t.G2.toAffine(Y(t,0,e.nextChallenge,a.key.tau.g1_s,a.key.tau.g1_sx)),a.key.alpha.g2_sp=t.G2.toAffine(Y(t,1,e.nextChallenge,a.key.alpha.g1_s,a.key.alpha.g1_sx)),a.key.beta.g2_sp=t.G2.toAffine(Y(t,2,e.nextChallenge,a.key.beta.g1_s,a.key.beta.g1_sx)),i=await wt(t,a.key.tau.g1_s,a.key.tau.g1_sx,a.key.tau.g2_sp,a.key.tau.g2_spx),!0!==i?(n&&n.error("INVALID key (tau) in challenge #"+a.id),!1):(i=await wt(t,a.key.alpha.g1_s,a.key.alpha.g1_sx,a.key.alpha.g2_sp,a.key.alpha.g2_spx),!0!==i?(n&&n.error("INVALID key (alpha) in challenge #"+a.id),!1):(i=await wt(t,a.key.beta.g1_s,a.key.beta.g1_sx,a.key.beta.g2_sp,a.key.beta.g2_spx),!0!==i?(n&&n.error("INVALID key (beta) in challenge #"+a.id),!1):(i=await wt(t,e.tauG1,a.tauG1,a.key.tau.g2_sp,a.key.tau.g2_spx),!0!==i?(n&&n.error("INVALID tau*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(i=await wt(t,a.key.tau.g1_s,a.key.tau.g1_sx,e.tauG2,a.tauG2),!0!==i?(n&&n.error("INVALID tau*G2. challenge #"+a.id+" It does not follow the previous contribution"),!1):(i=await wt(t,e.alphaG1,a.alphaG1,a.key.alpha.g2_sp,a.key.alpha.g2_spx),!0!==i?(n&&n.error("INVALID alpha*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(i=await wt(t,e.betaG1,a.betaG1,a.key.beta.g2_sp,a.key.beta.g2_spx),!0!==i?(n&&n.error("INVALID beta*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(i=await wt(t,a.key.beta.g1_s,a.key.beta.g1_sx,e.betaG2,a.betaG2),!0!==i?(n&&n.error("INVALID beta*G2. challenge #"+a.id+"It does not follow the previous contribution"),!1):(n&&n.info("Powers Of tau file OK!"),!0))))))))}async function pt(t,a,e,n,r,o,s,c,l,u){const d=r[o],w=2*d.F.n8,f=a[n][0].size/w;await i.startReadUniqueSection(t,a,n),await i.startWriteSection(e,n);let p=s;for(let i=0;i<f;i+=65536){u&&u.debug(`Applying key: ${l}: ${i}/${f}`);const a=Math.min(f-i,65536);let n;n=await t.read(a*w),n=await d.batchApplyKey(n,p,c),await e.write(n),p=r.Fr.mul(p,r.Fr.exp(c,a))}await i.endWriteSection(e),await i.endReadSection(t)}async function mt(t,a,e,n,i,r,o,s,c,l,u){const d=n[i],w=2*d.F.n8,f=Math.floor((1<<20)/w);let p=o;for(let m=0;m<r;m+=f){u&&u.debug(`Applying key ${l}: ${m}/${r}`);const i=Math.min(r-m,f),o=await t.read(i*w),g=await d.batchUtoLEM(o),h=await d.batchApplyKey(g,p,s);let b;b="COMPRESSED"==c?await d.batchLEMtoC(h):await d.batchLEMtoU(h),e&&e.update(b),await a.write(b),p=n.Fr.mul(p,n.Fr.exp(s,i))}}var gt=Object.freeze({__proto__:null,newAccumulator:async function(t,a,e,n){await p.default.ready();const r=await i.createBinFile(e,"ptau",1,7);await et(r,t,a,0);const o=t.G1.oneAffine,s=t.G2.oneAffine;await i.startWriteSection(r,2);const c=2**a*2-1;for(let i=0;i<c;i++)await r.write(o),n&&i%1e5==0&&i&&n.log("tauG1: "+i);await i.endWriteSection(r),await i.startWriteSection(r,3);const l=2**a;for(let i=0;i<l;i++)await r.write(s),n&&i%1e5==0&&i&&n.log("tauG2: "+i);await i.endWriteSection(r),await i.startWriteSection(r,4);const u=2**a;for(let i=0;i<u;i++)await r.write(o),n&&i%1e5==0&&i&&n.log("alphaTauG1: "+i);await i.endWriteSection(r),await i.startWriteSection(r,5);const d=2**a;for(let i=0;i<d;i++)await r.write(o),n&&i%1e5==0&&i&&n.log("betaTauG1: "+i);await i.endWriteSection(r),await i.startWriteSection(r,6),await r.write(s),await i.endWriteSection(r),await i.startWriteSection(r,7),await r.writeULE32(0),await i.endWriteSection(r),await r.close();const w=ut(t,a,n);return n&&n.debug(E(p.default(64).digest(),"Blank Contribution Hash:")),n&&n.info(E(w,"First Contribution Hash:")),w},exportChallenge:async function(t,a,e){await p.default.ready();const{fd:n,sections:r}=await i.readBinFile(t,"ptau",1),{curve:o,power:s}=await nt(n,r),l=await st(n,o,r);let u,d;0==l.length?(u=p.default(64).digest(),d=ut(o,s)):(u=l[l.length-1].responseHash,d=l[l.length-1].nextChallenge),e&&e.info(E(u,"Last Response Hash: ")),e&&e.info(E(d,"New Challenge Hash: "));const w=await c.createOverride(a),f=p.default(64);await w.write(u),f.update(u),await g(2,"G1",2**s*2-1,"tauG1"),await g(3,"G2",2**s,"tauG2"),await g(4,"G1",2**s,"alphaTauG1"),await g(5,"G1",2**s,"betaTauG1"),await g(6,"G2",1,"betaG2"),await n.close(),await w.close();const m=f.digest();if(!B(d,m))throw e&&e.info(E(m,"Calc Curret Challenge Hash: ")),e&&e.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),new Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return d;async function g(t,a,s,c){const l=o[a],u=2*l.F.n8,d=Math.floor((1<<24)/u);await i.startReadUniqueSection(n,r,t);for(let i=0;i<s;i+=d){e&&e.debug(`Exporting ${c}: ${i}/${s}`);const t=Math.min(s-i,d);let a;a=await n.read(t*u),a=await l.batchLEMtoU(a),await w.write(a),f.update(a)}await i.endReadSection(n)}},importResponse:async function(t,a,e,n,r,o){await p.default.ready();const s=new Uint8Array(64);for(let i=0;i<64;i++)s[i]=255;const{fd:l,sections:u}=await i.readBinFile(t,"ptau",1),{curve:d,power:w}=await nt(l,u),f=await st(l,d,u),m={};n&&(m.name=n);const g=2*d.F1.n8,h=d.F1.n8,b=2*d.F2.n8,y=d.F2.n8,G=await c.readExisting(a);if(G.totalSize!=64+(2**w*2-1)*h+2**w*y+2**w*h+2**w*h+y+6*g+3*b)throw new Error("Size of the contribution is invalid");let S;S=f.length>0?f[f.length-1].nextChallenge:ut(d,w,o);const _=await i.createBinFile(e,"ptau",1,r?7:2);await et(_,d,w);const v=await G.read(64);if(B(s,S)&&(S=v,f[f.length-1].nextChallenge=S),!B(v,S))throw new Error("Wrong contribution. this contribution is not based on the previus hash");const F=new p.default(64);F.update(v);const x=[];let A;A=await z(G,_,"G1",2,2**w*2-1,[1],"tauG1"),m.tauG1=A[0],A=await z(G,_,"G2",3,2**w,[1],"tauG2"),m.tauG2=A[0],A=await z(G,_,"G1",4,2**w,[0],"alphaG1"),m.alphaG1=A[0],A=await z(G,_,"G1",5,2**w,[0],"betaG1"),m.betaG1=A[0],A=await z(G,_,"G2",6,1,[0],"betaG2"),m.betaG2=A[0],m.partialHash=F.getPartialHash();const U=await G.read(2*d.F1.n8*6+2*d.F2.n8*3);m.key=it(U,0,d,!1),F.update(new Uint8Array(U));const L=F.digest();if(o&&o.info(E(L,"Contribution Response Hash imported: ")),r){const t=new p.default(64);t.update(L),await R(t,_,"G1",2,2**w*2-1,"tauG1",o),await R(t,_,"G2",3,2**w,"tauG2",o),await R(t,_,"G1",4,2**w,"alphaTauG1",o),await R(t,_,"G1",5,2**w,"betaTauG1",o),await R(t,_,"G2",6,1,"betaG2",o),m.nextChallenge=t.digest(),o&&o.info(E(m.nextChallenge,"Next Challenge Hash: "))}else m.nextChallenge=s;return f.push(m),await lt(_,d,f),await G.close(),await _.close(),await l.close(),m.nextChallenge;async function z(t,a,e,n,s,c,l){return r?await async function(t,a,e,n,r,s,c){const l=d[e],u=l.F.n8,w=2*l.F.n8,f=[];await i.startWriteSection(a,n);const p=Math.floor((1<<24)/w);x[n]=a.pos;for(let i=0;i<r;i+=p){o&&o.debug(`Importing ${c}: ${i}/${r}`);const e=Math.min(r-i,p),n=await t.read(e*u);F.update(n);const d=await l.batchCtoLEM(n);await a.write(d);for(let t=0;t<s.length;t++){const a=s[t];if(a>=i&&a<i+e){const t=l.fromRprLEM(d,(a-i)*w);f.push(t)}}}return await i.endWriteSection(a),f}(t,a,e,n,s,c,l):await async function(t,a,e,n,i,r,s){const c=d[e],l=c.F.n8,u=[],w=Math.floor((1<<24)/l);for(let d=0;d<i;d+=w){o&&o.debug(`Importing ${s}: ${d}/${i}`);const a=Math.min(i-d,w),e=await t.read(a*l);F.update(e);for(let t=0;t<r.length;t++){const n=r[t];if(n>=d&&n<d+a){const t=c.fromRprCompressed(e,(n-d)*l);u.push(t)}}}return u}(t,0,e,0,s,c,l)}async function R(t,a,e,n,i,r,o){const s=d[e],c=2*s.F.n8,l=Math.floor((1<<24)/c),u=a.pos;a.pos=x[n];for(let d=0;d<i;d+=l){o&&o.debug(`Hashing ${r}: ${d}/${i}`);const e=Math.min(i-d,l),n=await a.read(e*c),u=await s.batchLEMtoU(n);t.update(u)}a.pos=u}},verify:async function(t,a){let e;await p.default.ready();const{fd:n,sections:o}=await i.readBinFile(t,"ptau",1),{curve:s,power:c,ceremonyPower:l}=await nt(n,o),u=await st(n,s,o);a&&a.debug("power: 2**"+c),a&&a.debug("Computing initial contribution hash");const d={tauG1:s.G1.g,tauG2:s.G2.g,alphaG1:s.G1.g,betaG1:s.G1.g,betaG2:s.G2.g,nextChallenge:ut(s,l,a),responseHash:p.default(64).digest()};if(0==u.length)return a&&a.error("This file has no contribution! It cannot be used in production"),!1;let w;w=u.length>1?u[u.length-2]:d;const f=u[u.length-1];if(a&&a.debug("Validating contribution #"+u[u.length-1].id),!(await ft(s,f,w,a)))return!1;const g=p.default(64);g.update(f.responseHash),a&&a.debug("Verifying powers in tau*G1 section");const h=await F(2,"G1","tauG1",2**c*2-1,[0,1],a);if(e=await wt(s,h.R1,h.R2,s.G2.g,f.tauG2),!0!==e)return a&&a.error("tauG1 section. Powers do not match"),!1;if(!s.G1.eq(s.G1.g,h.singularPoints[0]))return a&&a.error("First element of tau*G1 section must be the generator"),!1;if(!s.G1.eq(f.tauG1,h.singularPoints[1]))return a&&a.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in tau*G2 section");const b=await F(3,"G2","tauG2",2**c,[0,1],a);if(e=await wt(s,s.G1.g,f.tauG1,b.R1,b.R2),!0!==e)return a&&a.error("tauG2 section. Powers do not match"),!1;if(!s.G2.eq(s.G2.g,b.singularPoints[0]))return a&&a.error("First element of tau*G2 section must be the generator"),!1;if(!s.G2.eq(f.tauG2,b.singularPoints[1]))return a&&a.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in alpha*tau*G1 section");const y=await F(4,"G1","alphatauG1",2**c,[0],a);if(e=await wt(s,y.R1,y.R2,s.G2.g,f.tauG2),!0!==e)return a&&a.error("alphaTauG1 section. Powers do not match"),!1;if(!s.G1.eq(f.alphaG1,y.singularPoints[0]))return a&&a.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in beta*tau*G1 section");const G=await F(5,"G1","betatauG1",2**c,[0],a);if(e=await wt(s,G.R1,G.R2,s.G2.g,f.tauG2),!0!==e)return a&&a.error("betaTauG1 section. Powers do not match"),!1;if(!s.G1.eq(f.betaG1,G.singularPoints[0]))return a&&a.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;const S=await async function(t){const a=s.G2,e=2*a.F.n8,i=new Uint8Array(e);if(!o[6])throw t.error("File has no BetaG2 section"),new Error("File has no BetaG2 section");if(o[6].length>1)throw t.error("File has no BetaG2 section"),new Error("File has more than one GetaG2 section");n.pos=o[6][0].p;const r=await n.read(e),c=a.fromRprLEM(r);return a.toRprUncompressed(i,0,c),g.update(i),c}(a);if(!s.G2.eq(f.betaG2,S))return a&&a.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;const _=g.digest();if(c==l&&!B(_,f.nextChallenge))return a&&a.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;a&&a.info(E(_,"Next challenge hash: ")),v(f,w);for(let i=u.length-2;i>=0;i--){const t=u[i],e=i>0?u[i-1]:d;if(!(await ft(s,t,e,a)))return!1;v(t,e)}if(a&&a.info("-----------------------------------------------------"),o[12]&&o[13]&&o[14]&&o[15]){let t;if(t=await x("G1",2,12,"tauG1",a),!t)return!1;if(t=await x("G2",3,13,"tauG2",a),!t)return!1;if(t=await x("G1",4,14,"alphaTauG1",a),!t)return!1;if(t=await x("G1",5,15,"betaTauG1",a),!t)return!1}else a&&a.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await n.close(),a&&a.info("Powers of Tau Ok!"),!0;function v(t,e){if(!a)return;a.info("-----------------------------------------------------"),a.info(`Contribution #${t.id}: ${t.name||""}`),a.info(E(t.nextChallenge,"Next Challenge: "));const n=new Uint8Array(2*s.G1.F.n8*6+2*s.G2.F.n8*3);rt(n,0,s,t.key,!1);const i=p.default(64);i.setPartialHash(t.partialHash),i.update(n);const r=i.digest();a.info(E(r,"Response Hash:")),a.info(E(e.nextChallenge,"Response Hash:")),1==t.type&&(a.info(`Beacon generator: ${R(t.beaconHash)}`),a.info(`Beacon iterations Exp: ${t.numIterationsExp}`))}async function F(t,a,e,r,c,l){const u=s[a],d=2*u.F.n8;await i.startReadUniqueSection(n,o,t);const w=[];let f=u.zero,p=u.zero,h=u.zero;for(let i=0;i<r;i+=65536){l&&l.debug(`points relations: ${e}: ${i}/${r} `);const t=Math.min(r-i,65536),a=await n.read(t*d),o=await u.batchLEMtoU(a);g.update(o);const s=new Uint8Array(4*(t-1));if(m.default.randomFillSync(s),i>0){const t=u.fromRprLEM(a,0),e=m.default.randomBytes(4).readUInt32BE(0,!0);f=u.add(f,u.timesScalar(h,e)),p=u.add(p,u.timesScalar(t,e))}const b=await u.multiExpAffine(a.slice(0,(t-1)*d),s),y=await u.multiExpAffine(a.slice(d),s);f=u.add(f,b),p=u.add(p,y),h=u.fromRprLEM(a,(t-1)*d);for(let e=0;e<c.length;e++){const n=c[e];if(n>=i&&n<i+t){const t=u.fromRprLEM(a,(n-i)*d);w.push(t)}}}return await i.endReadSection(n),{R1:f,R2:p,singularPoints:w}}async function x(t,a,e,l,u){u&&u.debug(`Verifying phase2 calculated values ${l}...`);const d=s[t],w=2*d.F.n8,f=new Array(8);for(let n=0;n<8;n++)f[n]=m.default.randomBytes(4).readUInt32BE(0,!0);for(let n=0;n<=c;n++){if(!(await p(n)))return!1}if(2==a){if(!(await p(c+1)))return!1}return!0;async function p(t){u&&u.debug(`Power ${t}...`);const p=s.Fr.n8,m=2**t;let g,h=new Uint32Array(m),b=new r.ChaCha(f);u&&u.debug(`Creating random numbers Powers${t}...`);for(let a=0;a<m;a++)h[a]=t==c+1&&a==m-1?0:b.nextU32();h=new Uint8Array(h.buffer,h.byteOffset,h.byteLength),u&&u.debug(`reading points Powers${t}...`),await i.startReadUniqueSection(n,o,a),g=new r.BigBuffer(m*w),t==c+1?(await n.readToBuffer(g,0,(m-1)*w),g.set(s.G1.zeroAffine,(m-1)*w)):await n.readToBuffer(g,0,m*w),await i.endReadSection(n,!0);const y=await d.multiExpAffine(g,h,u,l+"_"+t);h=new r.BigBuffer(m*p),b=new r.ChaCha(f);const G=new Uint8Array(4),S=new DataView(G.buffer);u&&u.debug(`Creating random numbers Powers${t}...`);for(let a=0;a<m;a++)a==m-1&&t==c+1||(S.setUint32(0,b.nextU32(),!0),h.set(G,a*p));u&&u.debug(`batchToMontgomery ${t}...`),h=await s.Fr.batchToMontgomery(h),u&&u.debug(`fft ${t}...`),h=await s.Fr.fft(h),u&&u.debug(`batchFromMontgomery ${t}...`),h=await s.Fr.batchFromMontgomery(h),u&&u.debug(`reading points Lagrange${t}...`),await i.startReadUniqueSection(n,o,e),n.pos+=w*(2**t-1),await n.readToBuffer(g,0,m*w),await i.endReadSection(n,!0);const _=await d.multiExpAffine(g,h,u,l+"_"+t+"_transformed");return!!d.eq(y,_)||(u&&u.error("Phase2 caclutation does not match with powers of tau"),!1)}}},challengeContribute:async function(t,a,e,n,i){await p.default.ready();const r=await c.readExisting(a),o=8*t.F1.n64*2,s=8*t.F2.n64*2,l=(r.totalSize+o-64-s)/(4*o+s);let u=l,d=0;for(;u>1;)u/=2,d+=1;if(2**d!=l)throw new Error("Invalid file size");i&&i.debug("Power to tau size: "+d);const w=await U(n),f=await c.createOverride(e),m=p.default(64);for(let c=0;c<r.totalSize;c+=r.pageSize){i&&i.debug(`Hashing challenge ${c}/${r.totalSize}`);const t=Math.min(r.totalSize-c,r.pageSize),a=await r.read(t);m.update(a)}const g=await r.read(64,0);i&&i.info(E(g,"Claimed Previous Response Hash: "));const h=m.digest();i&&i.info(E(h,"Current Challenge Hash: "));const b=at(t,h,w);i&&["tau","alpha","beta"].forEach((a=>{i.debug(a+".g1_s: "+t.G1.toString(b[a].g1_s,16)),i.debug(a+".g1_sx: "+t.G1.toString(b[a].g1_sx,16)),i.debug(a+".g2_sp: "+t.G2.toString(b[a].g2_sp,16)),i.debug(a+".g2_spx: "+t.G2.toString(b[a].g2_spx,16)),i.debug("")}));const y=p.default(64);await f.write(h),y.update(h),await mt(r,f,y,t,"G1",2**d*2-1,t.Fr.one,b.tau.prvKey,"COMPRESSED","tauG1",i),await mt(r,f,y,t,"G2",2**d,t.Fr.one,b.tau.prvKey,"COMPRESSED","tauG2",i),await mt(r,f,y,t,"G1",2**d,b.alpha.prvKey,b.tau.prvKey,"COMPRESSED","alphaTauG1",i),await mt(r,f,y,t,"G1",2**d,b.beta.prvKey,b.tau.prvKey,"COMPRESSED","betaTauG1",i),await mt(r,f,y,t,"G2",1,b.beta.prvKey,b.tau.prvKey,"COMPRESSED","betaTauG2",i);const G=new Uint8Array(2*t.F1.n8*6+2*t.F2.n8*3);rt(G,0,t,b,!1),await f.write(G),y.update(G);const S=y.digest();i&&i.info(E(S,"Contribution Response Hash: ")),await f.close(),await r.close()},beacon:async function(t,a,e,n,r,o){const s=z(n);if(0==s.byteLength||2*s.byteLength!=n.length)return o&&o.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(s.length>=256)return o&&o.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((r=parseInt(r))<10||r>63)return o&&o.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await p.default.ready();const{fd:c,sections:l}=await i.readBinFile(t,"ptau",1),{curve:u,power:d,ceremonyPower:w}=await nt(c,l);if(d!=w)return o&&o.error("This file has been reduced. You cannot contribute into a reduced file."),!1;l[12]&&o&&o.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const f=await st(c,u,l),m={name:e,type:1,numIterationsExp:r,beaconHash:s};let g;g=f.length>0?f[f.length-1].nextChallenge:ut(u,d,o),m.key=dt(u,g,s,r);const h=new p.default(64);h.update(g);const b=await i.createBinFile(a,"ptau",1,7);await et(b,u,d);const y=[];let G;G=await F(2,"G1",2**d*2-1,u.Fr.e(1),m.key.tau.prvKey,"tauG1",o),m.tauG1=G[1],G=await F(3,"G2",2**d,u.Fr.e(1),m.key.tau.prvKey,"tauG2",o),m.tauG2=G[1],G=await F(4,"G1",2**d,m.key.alpha.prvKey,m.key.tau.prvKey,"alphaTauG1",o),m.alphaG1=G[0],G=await F(5,"G1",2**d,m.key.beta.prvKey,m.key.tau.prvKey,"betaTauG1",o),m.betaG1=G[0],G=await F(6,"G2",1,m.key.beta.prvKey,m.key.tau.prvKey,"betaTauG2",o),m.betaG2=G[0],m.partialHash=h.getPartialHash();const S=new Uint8Array(2*u.F1.n8*6+2*u.F2.n8*3);rt(S,0,u,m.key,!1),h.update(new Uint8Array(S));const _=h.digest();o&&o.info(E(_,"Contribution Response Hash imported: "));const v=new p.default(64);return v.update(_),await B(b,"G1",2,2**d*2-1,"tauG1",o),await B(b,"G2",3,2**d,"tauG2",o),await B(b,"G1",4,2**d,"alphaTauG1",o),await B(b,"G1",5,2**d,"betaTauG1",o),await B(b,"G2",6,1,"betaG2",o),m.nextChallenge=v.digest(),o&&o.info(E(m.nextChallenge,"Next Challenge Hash: ")),f.push(m),await lt(b,u,f),await c.close(),await b.close(),_;async function F(t,a,e,n,r,o,s){const d=[];c.pos=l[t][0].p,await i.startWriteSection(b,t),y[t]=b.pos;const w=u[a],f=2*w.F.n8,p=Math.floor((1<<20)/f);let m=n;for(let i=0;i<e;i+=p){s&&s.debug(`applying key${o}: ${i}/${e}`);const t=Math.min(e-i,p),a=await c.read(t*f),n=await w.batchApplyKey(a,m,r),l=b.write(n),g=await w.batchLEMtoC(n);if(h.update(g),await l,0==i)for(let i=0;i<Math.min(2,e);i++)d.push(w.fromRprLEM(n,i*f));m=u.Fr.mul(m,u.Fr.exp(r,t))}return await i.endWriteSection(b),d}async function B(t,a,e,n,i,r){const o=u[a],s=2*o.F.n8,c=Math.floor((1<<24)/s),l=t.pos;t.pos=y[e];for(let u=0;u<n;u+=c){r&&r.debug(`Hashing ${i}: ${u}/${n}`);const a=Math.min(n-u,c),e=await t.read(a*s),l=await o.batchLEMtoU(e);v.update(l)}t.pos=l}},contribute:async function(t,a,e,n,r){await p.default.ready();const{fd:o,sections:s}=await i.readBinFile(t,"ptau",1),{curve:c,power:l,ceremonyPower:u}=await nt(o,s);if(l!=u)throw r&&r.error("This file has been reduced. You cannot contribute into a reduced file."),new Error("This file has been reduced. You cannot contribute into a reduced file.");s[12]&&r&&r.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const d=await st(o,c,s),w={name:e,type:0};let f;const m=await U(n);f=d.length>0?d[d.length-1].nextChallenge:ut(c,l,r),w.key=at(c,f,m);const g=new p.default(64);g.update(f);const h=await i.createBinFile(a,"ptau",1,7);await et(h,c,l);const b=[];let y;y=await v(2,"G1",2**l*2-1,c.Fr.e(1),w.key.tau.prvKey,"tauG1"),w.tauG1=y[1],y=await v(3,"G2",2**l,c.Fr.e(1),w.key.tau.prvKey,"tauG2"),w.tauG2=y[1],y=await v(4,"G1",2**l,w.key.alpha.prvKey,w.key.tau.prvKey,"alphaTauG1"),w.alphaG1=y[0],y=await v(5,"G1",2**l,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG1"),w.betaG1=y[0],y=await v(6,"G2",1,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG2"),w.betaG2=y[0],w.partialHash=g.getPartialHash();const G=new Uint8Array(2*c.F1.n8*6+2*c.F2.n8*3);rt(G,0,c,w.key,!1),g.update(new Uint8Array(G));const S=g.digest();r&&r.info(E(S,"Contribution Response Hash imported: "));const _=new p.default(64);return _.update(S),await F(h,"G1",2,2**l*2-1,"tauG1"),await F(h,"G2",3,2**l,"tauG2"),await F(h,"G1",4,2**l,"alphaTauG1"),await F(h,"G1",5,2**l,"betaTauG1"),await F(h,"G2",6,1,"betaG2"),w.nextChallenge=_.digest(),r&&r.info(E(w.nextChallenge,"Next Challenge Hash: ")),d.push(w),await lt(h,c,d),await o.close(),await h.close(),S;async function v(t,a,e,n,l,u){const d=[];o.pos=s[t][0].p,await i.startWriteSection(h,t),b[t]=h.pos;const w=c[a],f=2*w.F.n8,p=Math.floor((1<<20)/f);let m=n;for(let i=0;i<e;i+=p){r&&r.debug(`processing: ${u}: ${i}/${e}`);const t=Math.min(e-i,p),a=await o.read(t*f),n=await w.batchApplyKey(a,m,l),s=h.write(n),b=await w.batchLEMtoC(n);if(g.update(b),await s,0==i)for(let i=0;i<Math.min(2,e);i++)d.push(w.fromRprLEM(n,i*f));m=c.Fr.mul(m,c.Fr.exp(l,t))}return await i.endWriteSection(h),d}async function F(t,a,e,n,i){const o=c[a],s=2*o.F.n8,l=Math.floor((1<<24)/s),u=t.pos;t.pos=b[e];for(let c=0;c<n;c+=l){r&&c&&r.debug(`Hashing ${i}: `+c);const a=Math.min(n-c,l),e=await t.read(a*s),u=await o.batchLEMtoU(e);_.update(u)}t.pos=u}},preparePhase2:async function(t,a,e){const{fd:n,sections:o}=await i.readBinFile(t,"ptau",1),{curve:s,power:c}=await nt(n,o),l=await i.createBinFile(a,"ptau",1,11);return await et(l,s,c),await i.copySection(n,o,l,2),await i.copySection(n,o,l,3),await i.copySection(n,o,l,4),await i.copySection(n,o,l,5),await i.copySection(n,o,l,6),await i.copySection(n,o,l,7),await u(2,12,"G1","tauG1"),await u(3,13,"G2","tauG2"),await u(4,14,"G1","alphaTauG1"),await u(5,15,"G1","betaTauG1"),await n.close(),void(await l.close());async function u(t,a,u,d){e&&e.debug("Starting section: "+d),await i.startWriteSection(l,a);for(let e=0;e<=c;e++)await w(e);async function w(a){const w=2**a,f=s[u],p=(s.Fr,2*f.F.n8);f.F.n8;let m;m=new r.BigBuffer(w*p),await i.startReadUniqueSection(n,o,t),2==t&&a==c+1?(await n.readToBuffer(m,0,(w-1)*p),m.set(s.G1.zeroAffine,(w-1)*p)):await n.readToBuffer(m,0,w*p),await i.endReadSection(n,!0),m=await f.lagrangeEvaluations(m,"affine","affine",e,d),await l.write(m)}2==t&&await w(c+1),await i.endWriteSection(l)}},truncate:async function(t,a,e){const{fd:n,sections:r}=await i.readBinFile(t,"ptau",1),{curve:o,power:s,ceremonyPower:c}=await nt(n,r),l=2*o.G1.F.n8,u=2*o.G2.F.n8;for(let i=1;i<s;i++)await d(i);return await n.close(),!0;async function d(t){let s=t.toString();for(;s.length<2;)s="0"+s;e&&e.debug("Writing Power: "+s);const d=await i.createBinFile(a+s+".ptau","ptau",1,11);await et(d,o,t,c),await i.copySection(n,r,d,2,(2**t*2-1)*l),await i.copySection(n,r,d,3,2**t*u),await i.copySection(n,r,d,4,2**t*l),await i.copySection(n,r,d,5,2**t*l),await i.copySection(n,r,d,6,u),await i.copySection(n,r,d,7),await i.copySection(n,r,d,12,(2**(t+1)*2-1)*l),await i.copySection(n,r,d,13,(2**t*2-1)*u),await i.copySection(n,r,d,14,(2**t*2-1)*l),await i.copySection(n,r,d,15,(2**t*2-1)*l),await d.close()}},convert:async function(t,a,e){const{fd:n,sections:o}=await i.readBinFile(t,"ptau",1),{curve:s,power:c}=await nt(n,o),l=await i.createBinFile(a,"ptau",1,11);return await et(l,s,c),await i.copySection(n,o,l,2),await i.copySection(n,o,l,3),await i.copySection(n,o,l,4),await i.copySection(n,o,l,5),await i.copySection(n,o,l,6),await i.copySection(n,o,l,7),await async function(t,a,u,d){e&&e.debug("Starting section: "+d);await i.startWriteSection(l,a);const w=o[a][0].size,f=n.pageSize;await i.startReadUniqueSection(n,o,a);for(let e=0;e<w;e+=f){const t=Math.min(w-e,f),a=await n.read(t);await l.write(a)}await i.endReadSection(n),2==t&&await async function(a){const w=2**a,f=s[u],p=2*f.F.n8;let m;m=new r.BigBuffer(w*p),await i.startReadUniqueSection(n,o,t),2==t&&a==c+1?(await n.readToBuffer(m,0,(w-1)*p),m.set(s.G1.zeroAffine,(w-1)*p)):await n.readToBuffer(m,0,w*p);await i.endReadSection(n,!0),m=await f.lagrangeEvaluations(m,"affine","affine",e,d),await l.write(m)}(c+1);await i.endWriteSection(l)}(2,12,"G1","tauG1"),await i.copySection(n,o,l,13),await i.copySection(n,o,l,14),await i.copySection(n,o,l,15),await n.close(),void(await l.close())},exportJson:async function(t,a){const{fd:e,sections:n}=await i.readBinFile(t,"ptau",1),{curve:r,power:o}=await nt(e,n),s={};return s.q=r.q,s.power=o,s.contributions=await st(e,r,n),s.tauG1=await c(2,"G1",2**o*2-1,"tauG1"),s.tauG2=await c(3,"G2",2**o,"tauG2"),s.alphaTauG1=await c(4,"G1",2**o,"alphaTauG1"),s.betaTauG1=await c(5,"G1",2**o,"betaTauG1"),s.betaG2=await c(6,"G2",1,"betaG2"),s.lTauG1=await l(12,"G1","lTauG1"),s.lTauG2=await l(13,"G2","lTauG2"),s.lAlphaTauG1=await l(14,"G1","lAlphaTauG2"),s.lBetaTauG1=await l(15,"G1","lBetaTauG2"),await e.close(),s;async function c(t,o,s,c){const l=r[o],u=2*l.F.n8,d=[];await i.startReadUniqueSection(e,n,t);for(let n=0;n<s;n++){a&&n&&n%1e4==0&&console.log(`${c}: `+n);const t=await e.read(u);d.push(l.fromRprLEM(t,0))}return await i.endReadSection(e),d}async function l(t,s,c){const l=r[s],u=2*l.F.n8,d=[];await i.startReadUniqueSection(e,n,t);for(let n=0;n<=o;n++){a&&console.log(`${c}: Power: ${n}`),d[n]=[];const t=2**n;for(let i=0;i<t;i++){a&&i&&i%1e4==0&&console.log(`${c}: ${i}/${t}`);const r=await e.read(u);d[n].push(l.fromRprLEM(r,0))}}return await i.endReadSection(e),d}}});const ht=r.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),bt=r.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");function yt(t,a){if(a instanceof Uint8Array)return t.toString(a);if(Array.isArray(a))return a.map(yt.bind(null,t));if("object"==typeof a){const e={};return Object.keys(a).forEach((n=>{e[n]=yt(t,a[n])})),e}return"bigint"==typeof a||void 0!==a.eq?a.toString(10):a}var Gt=Object.freeze({__proto__:null,print:function(t,a,e){for(let i=0;i<t.constraints.length;i++)n(t.constraints[i]);function n(n){const i=e=>{let n="";return Object.keys(e).forEach((i=>{let r=a.varIdx2Name[i];"one"==r&&(r="");let o=t.curve.Fr.toString(e[i]);"1"==o&&(o=""),"-1"==o&&(o="-"),""!=n&&"-"!=o[0]&&(o="+"+o),""!=n&&(o=" "+o),n=n+o+r})),n},r=`[ ${i(n[0])} ] * [ ${i(n[1])} ] - [ ${i(n[2])} ] = 0`;e&&e.info(r)}},info:async function(t,a){const e=await u.readR1cs(t);return r.Scalar.eq(e.prime,bt)?a&&a.info("Curve: bn-128"):r.Scalar.eq(e.prime,ht)?a&&a.info("Curve: bls12-381"):a&&a.info(`Unknown Curve. Prime: ${r.Scalar.toString(e.prime)}`),a&&a.info(`# of Wires: ${e.nVars}`),a&&a.info(`# of Constraints: ${e.nConstraints}`),a&&a.info(`# of Private Inputs: ${e.nPrvInputs}`),a&&a.info(`# of Public Inputs: ${e.nPubInputs}`),a&&a.info(`# of Labels: ${e.nLabels}`),a&&a.info(`# of Outputs: ${e.nOutputs}`),e},exportJson:async function(t,a){const e=await u.readR1cs(t,!0,!0,!0,a),n=e.curve.Fr;return delete e.curve,yt(n,e)}});async function St(t){const a={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},e=await c.readExisting(t),n=await e.read(e.totalSize),i=new TextDecoder("utf-8").decode(n).split("\n");for(let o=0;o<i.length;o++){const t=i[o].split(",");4==t.length&&(a.varIdx2Name[t[1]]?a.varIdx2Name[t[1]]+="|"+t[3]:a.varIdx2Name[t[1]]=t[3],a.labelIdx2Name[t[0]]=t[3],a.componentIdx2Name[t[2]]||(a.componentIdx2Name[t[2]]=r(t[3])))}return await e.close(),a;function r(t){const a=t.split(".");return a.pop(),a.join(".")}}var _t=Object.freeze({__proto__:null,calculate:D,debug:async function(t,a,e,n,o,s){const u=await c.readExisting(a),d=await u.read(u.totalSize);await u.close();let w={sanityCheck:!0},f=await St(n);o.set&&(f||(f=await St(n)),w.logSetSignal=function(t,a){s&&s.info("SET "+f.labelIdx2Name[t]+" <-- "+a.toString())}),o.get&&(f||(f=await St(n)),w.logGetSignal=function(t,a){s&&s.info("GET "+f.labelIdx2Name[t]+" --\x3e "+a.toString())}),o.trigger&&(f||(f=await St(n)),w.logStartComponent=function(t){s&&s.info("START: "+f.componentIdx2Name[t])},w.logFinishComponent=function(t){s&&s.info("FINISH: "+f.componentIdx2Name[t])}),w.sym=f;const p=await l.WitnessCalculatorBuilder(d,w),m=await p.calculateWitness(t),g=await i.createBinFile(e,"wtns",2,2);await async function(t,a,e){await i.startWriteSection(t,1);const n=8*(Math.floor((r.Scalar.bitLength(e)-1)/64)+1);await t.writeULE32(n),await i.writeBigInt(t,e,n),await t.writeULE32(a.length),await i.endWriteSection(t),await i.startWriteSection(t,2);for(let r=0;r<a.length;r++)await i.writeBigInt(t,a[r],n);await i.endWriteSection(t,2)}(g,m,p.prime),await g.close()},exportJson:async function(t){return await async function(t){const{fd:a,sections:e}=await i.readBinFile(t,"wtns",2),{n8:n,nWitness:r}=await V(a,e);await i.startReadUniqueSection(a,e,2);const o=[];for(let s=0;s<r;s++){const t=await i.readBigInt(a,n);o.push(t)}return await i.endReadSection(a),await a.close(),o}(t)}});const vt=262144,Ft={get:function(t,a){return isNaN(a)?t[a]:t.getElement(a)},set:function(t,a,e){return isNaN(a)?(t[a]=e,!0):t.setElement(a,e)}};class Et{constructor(t){this.length=t||0,this.arr=new Array(vt);for(let a=0;a<t;a+=vt)this.arr[a/vt]=new Array(Math.min(vt,t-a));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,a){const e=new Array(a-t);for(let n=t;n<a;n++)e[n-t]=this.getElement(n);return e}getElement(t){t=parseInt(t);const a=Math.floor(t/vt),e=t%vt;return this.arr[a]?this.arr[a][e]:void 0}setElement(t,a){t=parseInt(t);const e=Math.floor(t/vt);this.arr[e]||(this.arr[e]=new Array(vt));const n=t%vt;return this.arr[e][n]=a,t>=this.length&&(this.length=t+1),!0}getKeys(){const t=new Bt;for(let a=0;a<this.arr.length;a++)if(this.arr[a])for(let e=0;e<this.arr[a].length;e++)"undefined"!==typeof this.arr[a][e]&&t.push(a*vt+e);return t}}class Bt{constructor(t){const a=new Et(t);return new Proxy(a,Ft)}}async function xt(t,a,e,n){await p.default.ready();const o=p.default(64),{fd:s,sections:c}=await i.readBinFile(a,"ptau",1,1<<22,1<<24),{curve:l,power:d}=await nt(s,c),{fd:w,sections:f}=await i.readBinFile(t,"r1cs",1,1<<22,1<<24),m=await u.readR1csHeader(w,f,!1),g=await i.createBinFile(e,"zkey",1,10,1<<22,1<<24),h=2*l.G1.F.n8,b=2*l.G2.F.n8;if(m.prime!=l.r)return n&&n.error("r1cs curve does not match powers of tau ceremony curve"),-1;const y=F(m.nConstraints+m.nPubInputs+m.nOutputs+1-1)+1;if(y>d)return n&&n.error(`circuit too big for this power of tau ceremony. ${m.nConstraints}*2 > 2**${d}`),-1;if(!c[12])return n&&n.error("Powers of tau is not prepared."),-1;const G=m.nOutputs+m.nPubInputs,S=2**y;await i.startWriteSection(g,1),await g.writeULE32(1),await i.endWriteSection(g),await i.startWriteSection(g,2);const _=l.q,v=8*(Math.floor((r.Scalar.bitLength(_)-1)/64)+1),B=l.r,x=8*(Math.floor((r.Scalar.bitLength(B)-1)/64)+1),A=r.Scalar.mod(r.Scalar.shl(1,8*x),B),U=l.Fr.e(r.Scalar.mod(r.Scalar.mul(A,A),B));let L,z,R;await g.writeULE32(v),await i.writeBigInt(g,_,v),await g.writeULE32(x),await i.writeBigInt(g,B,x),await g.writeULE32(m.nVars),await g.writeULE32(G),await g.writeULE32(S),L=await s.read(h,c[4][0].p),await g.write(L),L=await l.G1.batchLEMtoU(L),o.update(L),z=await s.read(h,c[5][0].p),await g.write(z),z=await l.G1.batchLEMtoU(z),o.update(z),R=await s.read(b,c[6][0].p),await g.write(R),R=await l.G2.batchLEMtoU(R),o.update(R);const k=new Uint8Array(h);l.G1.toRprLEM(k,0,l.G1.g);const C=new Uint8Array(b);l.G2.toRprLEM(C,0,l.G2.g);const I=new Uint8Array(h);l.G1.toRprUncompressed(I,0,l.G1.g);const $=new Uint8Array(b);l.G2.toRprUncompressed($,0,l.G2.g),await g.write(C),await g.write(k),await g.write(C),o.update($),o.update(I),o.update($),await i.endWriteSection(g),n&&n.info("Reading r1cs");let T=await i.readSection(w,f,2);const O=new Bt(m.nVars),M=new Bt(m.nVars),q=new Bt(m.nVars),P=new Bt(m.nVars-G-1),W=new Array(G+1);n&&n.info("Reading tauG1");let H=await i.readSection(s,c,12,(S-1)*h,S*h);n&&n.info("Reading tauG2");let j=await i.readSection(s,c,13,(S-1)*b,S*b);n&&n.info("Reading alphatauG1");let V=await i.readSection(s,c,14,(S-1)*h,S*h);n&&n.info("Reading betatauG1");let N=await i.readSection(s,c,15,(S-1)*h,S*h);await async function(){const t=new Uint8Array(12+l.Fr.n8),a=new DataView(t.buffer),e=new Uint8Array(l.Fr.n8);l.Fr.toRprLE(e,0,l.Fr.e(1));let o=0;function s(){const t=T.slice(o,o+4);o+=4;return new DataView(t.buffer).getUint32(0,!0)}const c=new Bt;for(let i=0;i<m.nConstraints;i++){n&&i%1e4==0&&n.debug(`processing constraints: ${i}/${m.nConstraints}`);const t=s();for(let n=0;n<t;n++){const t=s(),a=o;o+=l.Fr.n8;const e=0,n=h*i,r=3,u=h*i;"undefined"===typeof O[t]&&(O[t]=[]),O[t].push([e,n,a]),t<=G?("undefined"===typeof W[t]&&(W[t]=[]),W[t].push([r,u,a])):("undefined"===typeof P[t-G-1]&&(P[t-G-1]=[]),P[t-G-1].push([r,u,a])),c.push([0,i,t,a])}const a=s();for(let n=0;n<a;n++){const t=s(),a=o;o+=l.Fr.n8;const e=0,n=h*i,r=1,u=b*i,d=2,w=h*i;"undefined"===typeof M[t]&&(M[t]=[]),M[t].push([e,n,a]),"undefined"===typeof q[t]&&(q[t]=[]),q[t].push([r,u,a]),t<=G?("undefined"===typeof W[t]&&(W[t]=[]),W[t].push([d,w,a])):("undefined"===typeof P[t-G-1]&&(P[t-G-1]=[]),P[t-G-1].push([d,w,a])),c.push([1,i,t,a])}const e=s();for(let n=0;n<e;n++){const t=s(),a=o;o+=l.Fr.n8;const e=0,n=h*i;t<=G?("undefined"===typeof W[t]&&(W[t]=[]),W[t].push([e,n,a])):("undefined"===typeof P[t-G-1]&&(P[t-G-1]=[]),P[t-G-1].push([e,n,a]))}}for(let n=0;n<=G;n++){const t=0,a=h*(m.nConstraints+n),e=3,i=h*(m.nConstraints+n);"undefined"===typeof O[n]&&(O[n]=[]),O[n].push([t,a,-1]),"undefined"===typeof W[n]&&(W[n]=[]),W[n].push([e,i,-1]),c.push([0,m.nConstraints+n,n,-1])}await i.startWriteSection(g,4);const u=new r.BigBuffer(c.length*(12+l.Fr.n8)+4),d=new Uint8Array(4);new DataView(d.buffer).setUint32(0,c.length,!0),u.set(d);let w=4;for(let i=0;i<c.length;i++)n&&i%1e5==0&&n.debug(`writing coeffs: ${i}/${c.length}`),f(c[i]);function f(n){let i;a.setUint32(0,n[0],!0),a.setUint32(4,n[1],!0),a.setUint32(8,n[2],!0),i=n[3]>=0?l.Fr.fromRprLE(T.slice(n[3],n[3]+l.Fr.n8),0):l.Fr.fromRprLE(e,0);const r=l.Fr.mul(i,U);l.Fr.toRprLE(t,12,r),u.set(t,w),w+=t.length}await g.write(u),await i.endWriteSection(g)}(),await D(3,"G1",W,"IC"),await async function(){await i.startWriteSection(g,9);const t=new r.BigBuffer(S*h);if(y<l.Fr.s){let a=await i.readSection(s,c,12,(2*S-1)*h,2*S*h);for(let e=0;e<S;e++){n&&e%1e4==0&&n.debug(`spliting buffer: ${e}/${S}`);const i=a.slice((2*e+1)*h,(2*e+1)*h+h);t.set(i,e*h)}}else{if(y!=l.Fr.s)throw n&&n.error("Circuit too big"),new Error("Circuit too big for this curve");{const a=c[12][0].p+(2**(y+1)-1)*h;await s.readToBuffer(t,0,S*h,a+S*h)}}await g.write(t),await i.endWriteSection(g)}(),await async function(){X(S-1);for(let t=0;t<S-1;t+=16384){n&&n.debug(`HashingHPoints: ${t}/${S}`);const a=Math.min(S-1,16384);await Z(t,a)}}(),await D(8,"G1",P,"C"),await D(5,"G1",O,"A"),await D(6,"G1",M,"B1"),await D(7,"G2",q,"B2");const K=o.digest();return await i.startWriteSection(g,10),await g.write(K),await g.writeULE32(0),await i.endWriteSection(g),n&&n.info(E(K,"Circuit hash: ")),await g.close(),await w.close(),await s.close(),K;async function D(t,a,e,r){const s=l[a];X(e.length),await i.startWriteSection(g,t);let c=[],u=0;for(;u<e.length;){let t=0;for(;u<e.length&&t<l.tm.concurrency;){n&&n.debug(`Writing points start ${r}: ${u}/${e.length}`);let i=1,o=e[u]?e[u].length:0;for(;u+i<e.length&&o+(e[u+i]?e[u+i].length:0)<32768&&i<32768;)o+=e[u+i]?e[u+i].length:0,i++;const s=e.slice(u,u+i),l=u;c.push(Q(a,s,n,r).then((t=>(n&&n.debug(`Writing points end ${r}: ${l}/${e.length}`),t)))),u+=i,t++}const i=await Promise.all(c);for(let a=0;a<i.length;a++){await g.write(i[a][0]);const t=await s.batchLEMtoU(i[a][0]);o.update(t)}c=[]}await i.endWriteSection(g)}async function Q(t,a,e,n){const i=l[t],o=2*i.F.n8,s=3*i.F.n8,c=2*i.F.n8;let u,d,w,f;if("G1"==t)u="g1m_timesScalarAffine",d="g1m_multiexpAffine",w="g1m_batchToAffine",f="g1m_zero";else{if("G2"!=t)throw new Error("Invalid group");u="g2m_timesScalarAffine",d="g2m_multiexpAffine",w="g2m_batchToAffine",f="g2m_zero"}let p,m,g=0;for(let r=0;r<a.length;r++)g+=a[r]?a[r].length:0;g>32768?(p=new r.BigBuffer(g*o),m=new r.BigBuffer(g*l.Fr.n8)):(p=new Uint8Array(g*o),m=new Uint8Array(g*l.Fr.n8));let h=0,b=0;const y=[H,j,V,N],G=new Uint8Array(l.Fr.n8);l.Fr.toRprLE(G,0,l.Fr.e(1));let S=0;for(let r=0;r<a.length;r++)if(a[r])for(let t=0;t<a[r].length;t++)e&&t&&t%1e4==0&&e.debug(`Configuring big array ${n}: ${t}/${a[r].length}`),p.set(y[a[r][t][0]].slice(a[r][t][1],a[r][t][1]+o),S*o),a[r][t][2]>=0?m.set(T.slice(a[r][t][2],a[r][t][2]+l.Fr.n8),S*l.Fr.n8):m.set(G,S*l.Fr.n8),S++;if(a.length>1){const t=[];t.push({cmd:"ALLOCSET",var:0,buff:p}),t.push({cmd:"ALLOCSET",var:1,buff:m}),t.push({cmd:"ALLOC",var:2,len:a.length*s}),h=0,b=0;let e=0;for(let n=0;n<a.length;n++)a[n]?(1==a[n].length?t.push({cmd:"CALL",fnName:u,params:[{var:0,offset:h},{var:1,offset:b},{val:l.Fr.n8},{var:2,offset:e}]}):t.push({cmd:"CALL",fnName:d,params:[{var:0,offset:h},{var:1,offset:b},{val:l.Fr.n8},{val:a[n].length},{var:2,offset:e}]}),h+=o*a[n].length,b+=l.Fr.n8*a[n].length,e+=s):(t.push({cmd:"CALL",fnName:f,params:[{var:2,offset:e}]}),e+=s);t.push({cmd:"CALL",fnName:w,params:[{var:2},{val:a.length},{var:2}]}),t.push({cmd:"GET",out:0,var:2,len:a.length*c});return await l.tm.queueAction(t)}{let t=await i.multiExpAffine(p,m,e,n);return t=[i.toAffine(t)],t}}async function Z(t,a){const e=await s.read(a*h,c[2][0].p+(t+S)*h),n=await s.read(a*h,c[2][0].p+t*h),i=l.tm.concurrency,r=Math.floor(a/i),u=[];for(let o=0;o<i;o++){let t;if(t=o<i-1?r:a-o*r,0==t)continue;const s=e.slice(o*r*h,(o*r+t)*h),c=n.slice(o*r*h,(o*r+t)*h);u.push(J(s,c))}const d=await Promise.all(u);for(let s=0;s<d.length;s++)o.update(d[s][0])}async function J(t,a){const e=t.byteLength/h,n=3*l.G1.F.n8,i=[];i.push({cmd:"ALLOCSET",var:0,buff:t}),i.push({cmd:"ALLOCSET",var:1,buff:a}),i.push({cmd:"ALLOC",var:2,len:e*n});for(let r=0;r<e;r++)i.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:r*h},{var:1,offset:r*h},{var:2,offset:r*n}]});i.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:e},{var:2}]}),i.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:e},{var:2}]}),i.push({cmd:"GET",out:0,var:2,len:e*h});return await l.tm.queueAction(i)}function X(t){const a=new Uint8Array(4);new DataView(a.buffer,a.byteOffset,a.byteLength).setUint32(0,t,!1),o.update(a)}}const At=A;async function Ut(t,a,e,n){let o;await p.default.ready();const{fd:s,sections:c}=await i.readBinFile(e,"zkey",2),l=await O(s,c,!1);if("groth16"!=l.protocol)throw new Error("zkey file is not groth16");const u=await G(l.q),d=2*u.G1.F.n8,w=await q(s,u,c),f=p.default(64);f.update(w.csHash);let g=u.G1.g;for(let i=0;i<w.contributions.length;i++){const t=w.contributions[i],a=x(f);if(H(a,u,t.delta.g1_s),H(a,u,t.delta.g1_sx),!B(a.digest(),t.transcript))return console.log(`INVALID(${i}): Inconsistent transcript `),!1;const e=X(u,t.transcript);if(o=await At(u,t.delta.g1_s,t.delta.g1_sx,e,t.delta.g2_spx),!0!==o)return console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `),!1;if(o=await At(u,g,t.deltaAfter,e,t.delta.g2_spx),!0!==o)return console.log(`INVALID(${i}): deltaAfter does not fillow the public key `),!1;if(1==t.type){const a=L(t.beaconHash,t.numIterationsExp),e=u.Fr.fromRng(a),n=u.G1.toAffine(u.G1.fromRng(a)),r=u.G1.toAffine(u.G1.timesFr(n,e));if(!0!==u.G1.eq(n,t.delta.g1_s))return console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `),!1;if(!0!==u.G1.eq(r,t.delta.g1_sx))return console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `),!1}j(f,u,t);const n=p.default(64);j(n,u,t),t.contributionHash=n.digest(),g=t.deltaAfter}const{fd:h,sections:b}=await i.readBinFile(t,"zkey",2),y=await O(h,b,!1);if("groth16"!=y.protocol)throw new Error("zkeyinit file is not groth16");if(!r.Scalar.eq(y.q,l.q)||!r.Scalar.eq(y.r,l.r)||y.n8q!=l.n8q||y.n8r!=l.n8r)return n&&n.error("INVALID:  Different curves"),!1;if(y.nVars!=l.nVars||y.nPublic!=l.nPublic||y.domainSize!=l.domainSize)return n&&n.error("INVALID:  Different circuit parameters"),!1;if(!u.G1.eq(l.vk_alpha_1,y.vk_alpha_1))return n&&n.error("INVALID:  Invalid alpha1"),!1;if(!u.G1.eq(l.vk_beta_1,y.vk_beta_1))return n&&n.error("INVALID:  Invalid beta1"),!1;if(!u.G2.eq(l.vk_beta_2,y.vk_beta_2))return n&&n.error("INVALID:  Invalid beta2"),!1;if(!u.G2.eq(l.vk_gamma_2,y.vk_gamma_2))return n&&n.error("INVALID:  Invalid gamma2"),!1;if(!u.G1.eq(l.vk_delta_1,g))return n&&n.error("INVALID:  Invalid delta1"),!1;if(o=await At(u,u.G1.g,g,u.G2.g,l.vk_delta_2),!0!==o)return n&&n.error("INVALID:  Invalid delta2"),!1;const S=await q(h,u,b);if(!B(w.csHash,S.csHash))return n&&n.error("INVALID:  Circuit does not match"),!1;if(c[8][0].size!=d*(l.nVars-l.nPublic-1))return n&&n.error("INVALID:  Invalid L section size"),!1;if(c[9][0].size!=d*l.domainSize)return n&&n.error("INVALID:  Invalid H section size"),!1;let _;if(_=await i.sectionIsEqual(s,c,h,b,3),!_)return n&&n.error("INVALID:  IC section is not identical"),!1;if(_=await i.sectionIsEqual(s,c,h,b,4),!_)return n&&n.error("Coeffs section is not identical"),!1;if(_=await i.sectionIsEqual(s,c,h,b,5),!_)return n&&n.error("A section is not identical"),!1;if(_=await i.sectionIsEqual(s,c,h,b,6),!_)return n&&n.error("B1 section is not identical"),!1;if(_=await i.sectionIsEqual(s,c,h,b,7),!_)return n&&n.error("B2 section is not identical"),!1;if(o=await async function(t,a,e,r,s,c,l,d,w){const f=1<<20,p=u[t],g=2*p.F.n8;await i.startReadUniqueSection(a,e,c),await i.startReadUniqueSection(r,s,c);let h=p.zero,b=p.zero;const y=e[c][0].size/g;for(let i=0;i<y;i+=f){n&&n.debug(`Same ratio check ${w}:  ${i}/${y}`);const t=Math.min(y-i,f),e=await a.read(t*g),o=await r.read(t*g),s=new Uint8Array(4*t);m.default.randomFillSync(s);const c=await p.multiExpAffine(e,s),l=await p.multiExpAffine(o,s);h=p.add(h,c),b=p.add(b,l)}return await i.endReadSection(a),await i.endReadSection(r),0==y||(o=await At(u,h,b,l,d),!0===o)}("G1",h,b,s,c,8,l.vk_delta_2,y.vk_delta_2,"L section"),!0!==o)return n&&n.error("L section does not match"),!1;if(o=await async function(){const t=1<<20,e=u.G1,d=u.Fr,w=2*e.F.n8,{fd:f,sections:p}=await i.readBinFile(a,"ptau",1);let g=new r.BigBuffer(l.domainSize*l.n8r);const h=new Array(8);for(let a=0;a<8;a++)h[a]=m.default.randomBytes(4).readUInt32BE(0,!0);const b=new r.ChaCha(h);for(let a=0;a<l.domainSize-1;a++){const t=d.fromRng(b);d.toRprLE(g,a*l.n8r,t)}d.toRprLE(g,(l.domainSize-1)*l.n8r,d.zero);let G,S=e.zero;for(let a=0;a<l.domainSize;a+=t){n&&n.debug(`H Verificaition(tau):  ${a}/${l.domainSize}`);const i=Math.min(l.domainSize-a,t),r=await f.read(w*i,p[2][0].p+l.domainSize*w+a*w),o=await f.read(w*i,p[2][0].p+a*w),s=await v(r,o),c=g.slice(a*l.n8r,(a+i)*l.n8r),u=await e.multiExpAffine(s,c);S=e.add(S,u)}if(g=await d.batchToMontgomery(g),l.power<d.s)G=d.neg(d.e(2));else{const t=2**d.s,a=d.exp(d.shift,t);G=d.sub(a,d.one)}const _=l.power<d.s?d.w[l.power+1]:d.shift;g=await d.batchApplyKey(g,G,_),g=await d.fft(g),g=await d.batchFromMontgomery(g),await i.startReadUniqueSection(s,c,9);let F=e.zero;for(let a=0;a<l.domainSize;a+=t){n&&n.debug(`H Verificaition(lagrange):  ${a}/${l.domainSize}`);const i=Math.min(l.domainSize-a,t),r=await s.read(w*i),o=g.slice(a*l.n8r,(a+i)*l.n8r),c=await e.multiExpAffine(r,o);F=e.add(F,c)}return await i.endReadSection(s),o=await At(u,S,F,l.vk_delta_2,y.vk_delta_2),!0===o}(),!0!==o)return n&&n.error("H section does not match"),!1;n&&n.info(E(w.csHash,"Circuit Hash: ")),await s.close(),await h.close();for(let i=w.contributions.length-1;i>=0;i--){const t=w.contributions[i];n&&n.info("-------------------------"),n&&n.info(E(t.contributionHash,`contribution #${i+1} ${t.name?t.name:""}:`)),1==t.type&&(n&&n.info(`Beacon generator: ${R(t.beaconHash)}`),n&&n.info(`Beacon iterations Exp: ${t.numIterationsExp}`))}return n&&n.info("-------------------------"),n&&n.info("ZKey Ok!"),!0;async function v(t,a){const e=2*u.G1.F.n8,n=t.byteLength/e,i=u.tm.concurrency,r=Math.floor(n/i),o=[];for(let u=0;u<i;u++){let e;if(e=u<i-1?r:n-u*r,0==e)continue;const s=t.slice(u*r*d,(u*r+e)*d),c=a.slice(u*r*d,(u*r+e)*d);o.push(F(s,c))}const s=await Promise.all(o),c=new Uint8Array(n*e);let l=0;for(let u=0;u<s.length;u++)c.set(s[u][0],l),l+=s[u][0].byteLength;return c}async function F(t,a){const e=2*u.G1.F.n8,n=3*u.G1.F.n8,i=t.byteLength/e,r=[];r.push({cmd:"ALLOCSET",var:0,buff:t}),r.push({cmd:"ALLOCSET",var:1,buff:a}),r.push({cmd:"ALLOC",var:2,len:i*n});for(let o=0;o<i;o++)r.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:o*e},{var:1,offset:o*e},{var:2,offset:o*n}]});r.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:i},{var:2}]}),r.push({cmd:"GET",out:0,var:2,len:i*e});return await u.tm.queueAction(r)}}const{stringifyBigInts:Lt}=r.utils;async function zt(t){const{fd:a,sections:e}=await i.readBinFile(t,"zkey",2),n=await O(a,e);let r;if("groth16"==n.protocol)r=await async function(t,a,e){const n=await G(t.q),r=2*n.G1.F.n8,o=await n.pairing(t.vk_alpha_1,t.vk_beta_2);let s={protocol:t.protocol,curve:n.name,nPublic:t.nPublic,vk_alpha_1:n.G1.toObject(t.vk_alpha_1),vk_beta_2:n.G2.toObject(t.vk_beta_2),vk_gamma_2:n.G2.toObject(t.vk_gamma_2),vk_delta_2:n.G2.toObject(t.vk_delta_2),vk_alphabeta_12:n.Gt.toObject(o)};await i.startReadUniqueSection(a,e,3),s.IC=[];for(let i=0;i<=t.nPublic;i++){const t=await a.read(r),e=n.G1.toObject(t);s.IC.push(e)}return await i.endReadSection(a),s=Lt(s),s}(n,a,e);else{if("plonk"!=n.protocol)throw new Error("zkey file is not groth16");r=await async function(t){const a=await G(t.q);let e={protocol:t.protocol,curve:a.name,nPublic:t.nPublic,power:t.power,k1:a.Fr.toObject(t.k1),k2:a.Fr.toObject(t.k2),Qm:a.G1.toObject(t.Qm),Ql:a.G1.toObject(t.Ql),Qr:a.G1.toObject(t.Qr),Qo:a.G1.toObject(t.Qo),Qc:a.G1.toObject(t.Qc),S1:a.G1.toObject(t.S1),S2:a.G1.toObject(t.S2),S3:a.G1.toObject(t.S3),X_2:a.G2.toObject(t.X_2),w:a.Fr.toObject(a.Fr.w[t.power])};return e=Lt(e),e}(n)}return await a.close(),r}var Rt=Object.freeze({__proto__:null,newZKey:xt,exportBellman:async function(t,a,e){const{fd:n,sections:r}=await i.readBinFile(t,"zkey",2),o=await O(n,r);if("groth16"!=o.protocol)throw new Error("zkey file is not groth16");const s=await G(o.q),l=2*s.G1.F.n8,u=2*s.G2.F.n8,d=await q(n,s,r),w=await c.createOverride(a);let f;await S(o.vk_alpha_1),await S(o.vk_beta_1),await _(o.vk_beta_2),await _(o.vk_gamma_2),await S(o.vk_delta_1),await _(o.vk_delta_2),f=await i.readSection(n,r,3),f=await s.G1.batchLEMtoU(f),await v("G1",f);const p=await i.readSection(n,r,9);let m,g,h,b,y;m=await s.G1.fft(p,"affine","jacobian",e),m=await s.G1.batchApplyKey(m,s.Fr.neg(s.Fr.e(2)),s.Fr.w[o.power+1],"jacobian","affine",e),m=m.slice(0,m.byteLength-l),m=await s.G1.batchLEMtoU(m),await v("G1",m),g=await i.readSection(n,r,8),g=await s.G1.batchLEMtoU(g),await v("G1",g),h=await i.readSection(n,r,5),h=await s.G1.batchLEMtoU(h),await v("G1",h),b=await i.readSection(n,r,6),b=await s.G1.batchLEMtoU(b),await v("G1",b),y=await i.readSection(n,r,7),y=await s.G2.batchLEMtoU(y),await v("G2",y),await w.write(d.csHash),await async function(t){const a=new Uint8Array(4);new DataView(a.buffer,a.byteOffset,a.byteLength).setUint32(0,t,!1),await w.write(a)}(d.contributions.length);for(let i=0;i<d.contributions.length;i++){const t=d.contributions[i];await S(t.deltaAfter),await S(t.delta.g1_s),await S(t.delta.g1_sx),await _(t.delta.g2_spx),await w.write(t.transcript)}async function S(t){const a=new Uint8Array(l);s.G1.toRprUncompressed(a,0,t),await w.write(a)}async function _(t){const a=new Uint8Array(u);s.G2.toRprUncompressed(a,0,t),await w.write(a)}async function v(t,a){let e;e="G1"==t?l:u;const n=new Uint8Array(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,a.byteLength/e,!1),await w.write(n),await w.write(a)}await n.close(),await w.close()},importBellman:async function(t,a,e,n,r){const{fd:o,sections:s}=await i.readBinFile(t,"zkey",2),l=await O(o,s,!1);if("groth16"!=l.protocol)throw new Error("zkey file is not groth16");const u=await G(l.q),d=2*u.G1.F.n8,w=2*u.G2.F.n8,f=await q(o,u,s),p={},m=await c.readExisting(a);m.pos=3*d+3*w+8+d*l.nVars+4+d*(l.domainSize-1)+4+d*l.nVars+4+d*l.nVars+4+w*l.nVars,p.csHash=await m.read(64);const g=await m.readUBE32();p.contributions=[];for(let i=0;i<g;i++){const t={delta:{}};t.deltaAfter=await E(m),t.delta.g1_s=await E(m),t.delta.g1_sx=await E(m),t.delta.g2_spx=await x(m),t.transcript=await m.read(64),i<f.contributions.length&&(t.type=f.contributions[i].type,1==t.type&&(t.beaconHash=f.contributions[i].beaconHash,t.numIterationsExp=f.contributions[i].numIterationsExp),f.contributions[i].name&&(t.name=f.contributions[i].name)),p.contributions.push(t)}if(!B(p.csHash,f.csHash))return r&&r.error("Hash of the original circuit does not match with the MPC one"),!1;if(f.contributions.length>p.contributions.length)return r&&r.error("The impoerted file does not include new contributions"),!1;for(let i=0;i<f.contributions.length;i++)if(!A(f.contributions[i],p.contributions[i]))return r&&r.error(`Previos contribution ${i} does not match`),!1;if(n)for(let i=f.contributions.length;i<p.contributions.length;i++)p.contributions[i].name=n;const h=await i.createBinFile(e,"zkey",1,10);if(m.pos=0,m.pos+=d,m.pos+=d,m.pos+=w,m.pos+=w,l.vk_delta_1=await E(m),l.vk_delta_2=await x(m),await k(h,l),await m.readUBE32()!=l.nPublic+1)return r&&r.error("Invalid number of points in IC"),await h.discard(),!1;if(m.pos+=d*(l.nPublic+1),await i.copySection(o,s,h,3),await i.copySection(o,s,h,4),await m.readUBE32()!=l.domainSize-1)return r&&r.error("Invalid number of points in H"),await h.discard(),!1;let b;const y=await m.read(d*(l.domainSize-1)),S=await u.G1.batchUtoLEM(y);b=new Uint8Array(l.domainSize*d),b.set(S),u.G1.toRprLEM(b,d*(l.domainSize-1),u.G1.zeroAffine);const _=u.Fr.neg(u.Fr.inv(u.Fr.e(2))),v=u.Fr.inv(u.Fr.w[l.power+1]);if(b=await u.G1.batchApplyKey(b,_,v,"affine","jacobian",r),b=await u.G1.ifft(b,"jacobian","affine",r),await i.startWriteSection(h,9),await h.write(b),await i.endWriteSection(h),await m.readUBE32()!=l.nVars-l.nPublic-1)return r&&r.error("Invalid number of points in L"),await h.discard(),!1;let F;return F=await m.read(d*(l.nVars-l.nPublic-1)),F=await u.G1.batchUtoLEM(F),await i.startWriteSection(h,8),await h.write(F),await i.endWriteSection(h),await m.readUBE32()!=l.nVars?(r&&r.error("Invalid number of points in A"),await h.discard(),!1):(m.pos+=d*l.nVars,await i.copySection(o,s,h,5),await m.readUBE32()!=l.nVars?(r&&r.error("Invalid number of points in B1"),await h.discard(),!1):(m.pos+=d*l.nVars,await i.copySection(o,s,h,6),await m.readUBE32()!=l.nVars?(r&&r.error("Invalid number of points in B2"),await h.discard(),!1):(m.pos+=w*l.nVars,await i.copySection(o,s,h,7),await W(h,u,p),await m.close(),await h.close(),await o.close(),!0)));async function E(t){const a=await t.read(2*u.G1.F.n8);return u.G1.fromRprUncompressed(a,0)}async function x(t){const a=await t.read(2*u.G2.F.n8);return u.G2.fromRprUncompressed(a,0)}function A(t,a){return!!u.G1.eq(t.deltaAfter,a.deltaAfter)&&(!!u.G1.eq(t.delta.g1_s,a.delta.g1_s)&&(!!u.G1.eq(t.delta.g1_sx,a.delta.g1_sx)&&(!!u.G2.eq(t.delta.g2_spx,a.delta.g2_spx)&&!!B(t.transcript,a.transcript))))}},verifyFromR1cs:async function(t,a,e,n){const i={type:"bigMem"};return await xt(t,a,i,n),await Ut(i,a,e,n)},verifyFromInit:Ut,contribute:async function(t,a,e,n,r){await p.default.ready();const{fd:o,sections:s}=await i.readBinFile(t,"zkey",2),c=await O(o,s);if("groth16"!=c.protocol)throw new Error("zkey file is not groth16");const l=await G(c.q),u=await q(o,l,s),d=await i.createBinFile(a,"zkey",1,10),w=await U(n),f=p.default(64);f.update(u.csHash);for(let i=0;i<u.contributions.length;i++)j(f,l,u.contributions[i]);const m={delta:{}};m.delta.prvKey=l.Fr.fromRng(w),m.delta.g1_s=l.G1.toAffine(l.G1.fromRng(w)),m.delta.g1_sx=l.G1.toAffine(l.G1.timesFr(m.delta.g1_s,m.delta.prvKey)),H(f,l,m.delta.g1_s),H(f,l,m.delta.g1_sx),m.transcript=f.digest(),m.delta.g2_sp=X(l,m.transcript),m.delta.g2_spx=l.G2.toAffine(l.G2.timesFr(m.delta.g2_sp,m.delta.prvKey)),c.vk_delta_1=l.G1.timesFr(c.vk_delta_1,m.delta.prvKey),c.vk_delta_2=l.G2.timesFr(c.vk_delta_2,m.delta.prvKey),m.deltaAfter=c.vk_delta_1,m.type=0,e&&(m.name=e),u.contributions.push(m),await k(d,c),await i.copySection(o,s,d,3),await i.copySection(o,s,d,4),await i.copySection(o,s,d,5),await i.copySection(o,s,d,6),await i.copySection(o,s,d,7);const g=l.Fr.inv(m.delta.prvKey);await pt(o,s,d,8,l,"G1",g,l.Fr.e(1),"L Section",r),await pt(o,s,d,9,l,"G1",g,l.Fr.e(1),"H Section",r),await W(d,l,u),await o.close(),await d.close();const h=p.default(64);j(h,l,m);const b=h.digest();return r&&r.info(E(u.csHash,"Circuit Hash: ")),r&&r.info(E(b,"Contribution Hash: ")),b},beacon:async function(t,a,e,n,r,o){await p.default.ready();const s=z(n);if(0==s.byteLength||2*s.byteLength!=n.length)return o&&o.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(s.length>=256)return o&&o.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((r=parseInt(r))<10||r>63)return o&&o.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;const{fd:c,sections:l}=await i.readBinFile(t,"zkey",2),u=await O(c,l);if("groth16"!=u.protocol)throw new Error("zkey file is not groth16");const d=await G(u.q),w=await q(c,d,l),f=await i.createBinFile(a,"zkey",1,10),m=await L(s,r),g=p.default(64);g.update(w.csHash);for(let i=0;i<w.contributions.length;i++)j(g,d,w.contributions[i]);const h={delta:{}};h.delta.prvKey=d.Fr.fromRng(m),h.delta.g1_s=d.G1.toAffine(d.G1.fromRng(m)),h.delta.g1_sx=d.G1.toAffine(d.G1.timesFr(h.delta.g1_s,h.delta.prvKey)),H(g,d,h.delta.g1_s),H(g,d,h.delta.g1_sx),h.transcript=g.digest(),h.delta.g2_sp=X(d,h.transcript),h.delta.g2_spx=d.G2.toAffine(d.G2.timesFr(h.delta.g2_sp,h.delta.prvKey)),u.vk_delta_1=d.G1.timesFr(u.vk_delta_1,h.delta.prvKey),u.vk_delta_2=d.G2.timesFr(u.vk_delta_2,h.delta.prvKey),h.deltaAfter=u.vk_delta_1,h.type=1,h.numIterationsExp=r,h.beaconHash=s,e&&(h.name=e),w.contributions.push(h),await k(f,u),await i.copySection(c,l,f,3),await i.copySection(c,l,f,4),await i.copySection(c,l,f,5),await i.copySection(c,l,f,6),await i.copySection(c,l,f,7);const b=d.Fr.inv(h.delta.prvKey);await pt(c,l,f,8,d,"G1",b,d.Fr.e(1),"L Section",o),await pt(c,l,f,9,d,"G1",b,d.Fr.e(1),"H Section",o),await W(f,d,w),await c.close(),await f.close();const y=p.default(64);j(y,d,h);const S=y.digest();return o&&o.info(E(S,"Contribution Hash: ")),S},exportJson:async function(t){const a=await async function(t,a){const{fd:e,sections:n}=await i.readBinFile(t,"zkey",1),o=await O(e,n,"groth16"),s=new r.F1Field(o.r),c=r.Scalar.mod(r.Scalar.shl(1,8*o.n8r),o.r),l=s.inv(c),u=s.mul(l,l);let d=await G(o.q);await i.startReadUniqueSection(e,n,3),o.IC=[];for(let i=0;i<=o.nPublic;i++){const t=await $(e,d,a);o.IC.push(t)}await i.endReadSection(e),await i.startReadUniqueSection(e,n,4);const w=await e.readULE32();o.ccoefs=[];for(let i=0;i<w;i++){const t=await e.readULE32(),a=await e.readULE32(),n=await e.readULE32(),i=await f();o.ccoefs.push({matrix:t,constraint:a,signal:n,value:i})}await i.endReadSection(e),await i.startReadUniqueSection(e,n,5),o.A=[];for(let i=0;i<o.nVars;i++){const t=await $(e,d,a);o.A[i]=t}await i.endReadSection(e),await i.startReadUniqueSection(e,n,6),o.B1=[];for(let i=0;i<o.nVars;i++){const t=await $(e,d,a);o.B1[i]=t}await i.endReadSection(e),await i.startReadUniqueSection(e,n,7),o.B2=[];for(let i=0;i<o.nVars;i++){const t=await T(e,d,a);o.B2[i]=t}await i.endReadSection(e),await i.startReadUniqueSection(e,n,8),o.C=[];for(let i=o.nPublic+1;i<o.nVars;i++){const t=await $(e,d,a);o.C[i]=t}await i.endReadSection(e),await i.startReadUniqueSection(e,n,9),o.hExps=[];for(let i=0;i<o.domainSize;i++){const t=await $(e,d,a);o.hExps.push(t)}return await i.endReadSection(e),await e.close(),o;async function f(){const t=await i.readBigInt(e,o.n8r);return s.mul(t,u)}}(t,!0);return a},bellmanContribute:async function(t,a,e,n,i){await p.default.ready();const r=await U(n),o=t.Fr.fromRng(r),s=t.Fr.inv(o),l=2*t.G1.F.n8,u=2*t.G2.F.n8,d=await c.readExisting(a),w=await c.createOverride(e);await R(l),await R(l),await R(u),await R(u);const f=await k(),m=t.G1.timesFr(f,o);await I(m);const g=await C(),h=t.G2.timesFr(g,o);await $(h);const b=await d.readUBE32();await w.writeUBE32(b),await R(b*l);const y=await d.readUBE32();await w.writeUBE32(y),await mt(d,w,null,t,"G1",y,s,t.Fr.e(1),"UNCOMPRESSED","H",i);const G=await d.readUBE32();await w.writeUBE32(G),await mt(d,w,null,t,"G1",G,s,t.Fr.e(1),"UNCOMPRESSED","L",i);const S=await d.readUBE32();await w.writeUBE32(S),await R(S*l);const _=await d.readUBE32();await w.writeUBE32(_),await R(_*l);const v=await d.readUBE32();await w.writeUBE32(v),await R(v*u);const F=p.default(64),B={};B.csHash=await d.read(64),F.update(B.csHash);const x=await d.readUBE32();B.contributions=[];for(let c=0;c<x;c++){const a={delta:{}};a.deltaAfter=await k(),a.delta.g1_s=await k(),a.delta.g1_sx=await k(),a.delta.g2_spx=await C(),a.transcript=await d.read(64),B.contributions.push(a),j(F,t,a)}const A={delta:{}};A.delta.prvKey=o,A.delta.g1_s=t.G1.toAffine(t.G1.fromRng(r)),A.delta.g1_sx=t.G1.toAffine(t.G1.timesFr(A.delta.g1_s,o)),H(F,t,A.delta.g1_s),H(F,t,A.delta.g1_sx),A.transcript=F.digest(),A.delta.g2_sp=X(t,A.transcript),A.delta.g2_spx=t.G2.toAffine(t.G2.timesFr(A.delta.g2_sp,o)),A.deltaAfter=m,A.type=0,B.contributions.push(A),await w.write(B.csHash),await w.writeUBE32(B.contributions.length);for(let c=0;c<B.contributions.length;c++){const t=B.contributions[c];await I(t.deltaAfter),await I(t.delta.g1_s),await I(t.delta.g1_sx),await $(t.delta.g2_spx),await w.write(t.transcript)}const L=p.default(64);j(L,t,A);const z=L.digest();return i&&i.info(E(z,"Contribution Hash: ")),await w.close(),await d.close(),z;async function R(t){const a=2*d.pageSize;for(let e=0;e<t;e+=a){const n=Math.min(t-e,a),i=await d.read(n);await w.write(i)}}async function k(){const a=await d.read(2*t.G1.F.n8);return t.G1.fromRprUncompressed(a,0)}async function C(){const a=await d.read(2*t.G2.F.n8);return t.G2.fromRprUncompressed(a,0)}async function I(a){const e=new Uint8Array(l);t.G1.toRprUncompressed(e,0,a),await w.write(e)}async function $(a){const e=new Uint8Array(u);t.G2.toRprUncompressed(e,0,a),await w.write(e)}},exportVerificationKey:zt,exportSolidityVerifier:async function(t,a,e){const n=await zt(t);let i=a[n.protocol];return g.default.render(i,n)}});const{stringifyBigInts:kt}=r.utils,{keccak256:Ct}=h.default;async function It(t,a,e){const{fd:n,sections:o}=await i.readBinFile(a,"wtns",2,1<<25,1<<23),s=await V(n,o),{fd:c,sections:l}=await i.readBinFile(t,"zkey",2,1<<25,1<<23),u=await O(c,l);if("plonk"!=u.protocol)throw new Error("zkey file is not groth16");if(!r.Scalar.eq(u.r,s.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(s.nWitness!=u.nVars-u.nAdditions)throw new Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${s.nWitness}, ${u.nAdditions}`);const d=await G(u.q),w=d.Fr,f=d.G1,p=d.Fr.n8;e&&e.debug("Reading Wtns");const m=await i.readSection(n,o,2);m.set(w.zero,0);const g=new r.BigBuffer(p*u.nAdditions);let h,b,y,S,_,v,F,E,B,x,A,U,L,z;await async function(){const t=await i.readSection(c,l,3),a=8+2*d.Fr.n8;for(let e=0;e<u.nAdditions;e++){const n=P(t,e*a),i=P(t,e*a+4),r=t.slice(e*a+8,e*a+8+p),o=t.slice(e*a+8+p,e*a+8+2*p),s=W(n),c=W(i),l=d.Fr.add(d.Fr.mul(r,s),d.Fr.mul(o,c));g.set(l,p*e)}}();let R={};const k=new r.BigBuffer(u.domainSize*p*4*3);let C=l[12][0].p+u.domainSize*p;await c.readToBuffer(k,0,u.domainSize*p*4,C),C+=u.domainSize*p*5,await c.readToBuffer(k,u.domainSize*p*4,u.domainSize*p*4,C),C+=u.domainSize*p*5,await c.readToBuffer(k,u.domainSize*p*8,u.domainSize*p*4,C);const I=new r.BigBuffer(u.domainSize*p);await c.readToBuffer(I,0,u.domainSize*p,l[12][0].p);const $=new r.BigBuffer(u.domainSize*p);await c.readToBuffer($,0,u.domainSize*p,l[12][0].p+5*u.domainSize*p);const T=await i.readSection(c,l,14),M={};await async function(){M.b=[];for(let t=1;t<=9;t++)M.b[t]=d.Fr.random();[h,b,y]=await async function(){let t=new r.BigBuffer(u.domainSize*p),a=new r.BigBuffer(u.domainSize*p),e=new r.BigBuffer(u.domainSize*p);const n=await i.readSection(c,l,4),o=await i.readSection(c,l,5),s=await i.readSection(c,l,6);for(let i=0;i<u.nConstrains;i++){const r=P(n,4*i);t.set(W(r),i*p);const c=P(o,4*i);a.set(W(c),i*p);const l=P(s,4*i);e.set(W(l),i*p)}return t=await w.batchToMontgomery(t),a=await w.batchToMontgomery(a),e=await w.batchToMontgomery(e),[t,a,e]}(),[B,_]=await D(h,[M.b[2],M.b[1]]),[x,v]=await D(b,[M.b[4],M.b[3]]),[A,F]=await D(y,[M.b[6],M.b[5]]),R.A=await K(B,"multiexp A"),R.B=await K(x,"multiexp B"),R.C=await K(A,"multiexp C")}(),await async function(){const t=new Uint8Array(2*f.F.n8*3);f.toRprUncompressed(t,0,R.A),f.toRprUncompressed(t,2*f.F.n8,R.B),f.toRprUncompressed(t,4*f.F.n8,R.C),M.beta=H(t),e&&e.debug("beta: "+w.toString(M.beta));const a=new Uint8Array(p);w.toRprBE(a,0,M.beta),M.gamma=H(a),e&&e.debug("gamma: "+w.toString(M.gamma));let n=new r.BigBuffer(w.n8*u.domainSize),i=new r.BigBuffer(w.n8*u.domainSize);n.set(w.one,0),i.set(w.one,0);let o=w.one;for(let e=0;e<u.domainSize;e++){let t=h.slice(e*p,(e+1)*p);t=w.add(t,w.mul(M.beta,o)),t=w.add(t,M.gamma);let a=b.slice(e*p,(e+1)*p);a=w.add(a,w.mul(u.k1,w.mul(M.beta,o))),a=w.add(a,M.gamma);let r=y.slice(e*p,(e+1)*p);r=w.add(r,w.mul(u.k2,w.mul(M.beta,o))),r=w.add(r,M.gamma);const s=w.mul(t,w.mul(a,r));let c=h.slice(e*p,(e+1)*p);c=w.add(c,w.mul(k.slice(e*p*4,e*p*4+p),M.beta)),c=w.add(c,M.gamma);let l=b.slice(e*p,(e+1)*p);l=w.add(l,w.mul(k.slice(4*(u.domainSize+e)*p,4*(u.domainSize+e)*p+p),M.beta)),l=w.add(l,M.gamma);let d=y.slice(e*p,(e+1)*p);d=w.add(d,w.mul(k.slice(4*(2*u.domainSize+e)*p,4*(2*u.domainSize+e)*p+p),M.beta)),d=w.add(d,M.gamma);const f=w.mul(c,w.mul(l,d));n.set(w.mul(n.slice(e*p,(e+1)*p),s),(e+1)%u.domainSize*p),i.set(w.mul(i.slice(e*p,(e+1)*p),f),(e+1)%u.domainSize*p),o=w.mul(o,w.w[u.power])}i=await w.batchInverse(i);for(let e=0;e<u.domainSize;e++)n.set(w.mul(n.slice(e*p,(e+1)*p),i.slice(e*p,(e+1)*p)),e*p);if(!w.eq(n.slice(0,p),w.one))throw new Error("Copy constraints does not match");S=n,[U,E]=await D(S,[M.b[9],M.b[8],M.b[7]]),R.Z=await K(U,"multiexp Z")}(),await async function(){e&&e.debug("phse3: Reading QM4");const t=new r.BigBuffer(4*u.domainSize*p);await c.readToBuffer(t,0,u.domainSize*p*4,l[7][0].p+u.domainSize*p),e&&e.debug("phse3: Reading QL4");const a=new r.BigBuffer(4*u.domainSize*p);await c.readToBuffer(a,0,u.domainSize*p*4,l[8][0].p+u.domainSize*p),e&&e.debug("phse3: Reading QR4");const n=new r.BigBuffer(4*u.domainSize*p);await c.readToBuffer(n,0,u.domainSize*p*4,l[9][0].p+u.domainSize*p),e&&e.debug("phse3: Reading QO4");const o=new r.BigBuffer(4*u.domainSize*p);await c.readToBuffer(o,0,u.domainSize*p*4,l[10][0].p+u.domainSize*p),e&&e.debug("phse3: Reading QC4");const s=new r.BigBuffer(4*u.domainSize*p);await c.readToBuffer(s,0,u.domainSize*p*4,l[11][0].p+u.domainSize*p);const d=await i.readSection(c,l,13),m=new Uint8Array(2*f.F.n8);f.toRprUncompressed(m,0,R.Z),M.alpha=H(m),e&&e.debug("alpha: "+w.toString(M.alpha));const g=[w.zero,w.add(w.e(-1),w.w[2]),w.e(-2),w.sub(w.e(-1),w.w[2])],b=[w.zero,w.add(w.zero,w.mul(w.e(-2),w.w[2])),w.e(4),w.sub(w.zero,w.mul(w.e(-2),w.w[2]))],y=[w.zero,w.add(w.e(2),w.mul(w.e(2),w.w[2])),w.e(-8),w.sub(w.e(2),w.mul(w.e(2),w.w[2]))],G=new r.BigBuffer(4*u.domainSize*p),S=new r.BigBuffer(4*u.domainSize*p);let B=w.one;for(let i=0;i<4*u.domainSize;i++){i%4096==0&&e&&e.debug(`calculating t ${i}/${4*u.domainSize}`);const r=_.slice(i*p,i*p+p),c=v.slice(i*p,i*p+p),l=F.slice(i*p,i*p+p),f=E.slice(i*p,i*p+p),m=E.slice((i+4*u.domainSize+4)%(4*u.domainSize)*p,(i+4*u.domainSize+4)%(4*u.domainSize)*p+p),g=t.slice(i*p,i*p+p),b=a.slice(i*p,i*p+p),y=n.slice(i*p,i*p+p),x=o.slice(i*p,i*p+p),A=s.slice(i*p,i*p+p),L=k.slice(i*p,i*p+p),R=k.slice((i+4*u.domainSize)*p,(i+4*u.domainSize)*p+p),C=k.slice((i+8*u.domainSize)*p,(i+8*u.domainSize)*p+p),I=w.add(M.b[2],w.mul(M.b[1],B)),$=w.add(M.b[4],w.mul(M.b[3],B)),T=w.add(M.b[6],w.mul(M.b[5],B)),O=w.square(B),q=w.add(w.add(w.mul(M.b[7],O),w.mul(M.b[8],B)),M.b[9]),P=w.mul(B,w.w[u.power]),W=w.square(P),H=w.add(w.add(w.mul(M.b[7],W),w.mul(M.b[8],P)),M.b[9]);let j=w.zero;for(let t=0;t<u.nPublic;t++)j=w.sub(j,w.mul(d.slice((5*t*u.domainSize+u.domainSize+i)*p,(5*t*u.domainSize+u.domainSize+i+1)*p),h.slice(t*p,(t+1)*p)));let[V,N]=U(r,c,I,$,i%4);V=w.mul(V,g),N=w.mul(N,g),V=w.add(V,w.mul(r,b)),N=w.add(N,w.mul(I,b)),V=w.add(V,w.mul(c,y)),N=w.add(N,w.mul($,y)),V=w.add(V,w.mul(l,x)),N=w.add(N,w.mul(T,x)),V=w.add(V,j),V=w.add(V,A);const K=w.mul(M.beta,B);let D=r;D=w.add(D,K),D=w.add(D,M.gamma);let Q=c;Q=w.add(Q,w.mul(K,u.k1)),Q=w.add(Q,M.gamma);let Z=l;Z=w.add(Z,w.mul(K,u.k2)),Z=w.add(Z,M.gamma);let J=f,[X,Y]=z(D,Q,Z,J,I,$,T,q,i%4);X=w.mul(X,M.alpha),Y=w.mul(Y,M.alpha);let tt=r;tt=w.add(tt,w.mul(M.beta,L)),tt=w.add(tt,M.gamma);let at=c;at=w.add(at,w.mul(M.beta,R)),at=w.add(at,M.gamma);let et=l;et=w.add(et,w.mul(M.beta,C)),et=w.add(et,M.gamma);let nt=m,[it,rt]=z(tt,at,et,nt,I,$,T,H,i%4);it=w.mul(it,M.alpha),rt=w.mul(rt,M.alpha);let ot=w.sub(f,w.one);ot=w.mul(ot,d.slice((u.domainSize+i)*p,(u.domainSize+i+1)*p)),ot=w.mul(ot,w.mul(M.alpha,M.alpha));let st=w.mul(q,d.slice((u.domainSize+i)*p,(u.domainSize+i+1)*p));st=w.mul(st,w.mul(M.alpha,M.alpha));let ct=w.add(w.sub(w.add(V,X),it),ot),lt=w.add(w.sub(w.add(N,Y),rt),st);G.set(ct,i*p),S.set(lt,i*p),B=w.mul(B,w.w[u.power+2])}e&&e.debug("ifft T");let x=await w.ifft(G);e&&e.debug("dividing T/Z");for(let e=0;e<u.domainSize;e++)x.set(w.neg(x.slice(e*p,e*p+p)),e*p);for(let e=u.domainSize;e<4*u.domainSize;e++){const t=w.sub(x.slice((e-u.domainSize)*p,(e-u.domainSize)*p+p),x.slice(e*p,e*p+p));if(x.set(t,e*p),e>3*u.domainSize-4&&!w.isZero(t))throw new Error("T Polynomial is not divisible")}e&&e.debug("ifft Tz");const A=await w.ifft(S);for(let e=0;e<4*u.domainSize;e++){const t=A.slice(e*p,(e+1)*p);if(e>3*u.domainSize+5){if(!w.isZero(t))throw new Error("Tz Polynomial is not well calculated")}else x.set(w.add(x.slice(e*p,(e+1)*p),t),e*p)}function U(t,a,e,n,i){let r,o;const s=w.mul(t,a),c=w.mul(t,n),l=w.mul(e,a);r=s;let u=w.mul(e,n);return o=w.add(c,l),i&&(o=w.add(o,w.mul(g[i],u))),[r,o]}function z(t,a,e,n,i,r,o,s,c){let l,u;const d=w.mul(t,a),f=w.mul(t,r),p=w.mul(i,a),m=w.mul(i,r),h=w.mul(e,n),G=w.mul(e,s),S=w.mul(o,n),_=w.mul(o,s);l=w.mul(d,h);let v=w.mul(p,h);v=w.add(v,w.mul(f,h)),v=w.add(v,w.mul(d,S)),v=w.add(v,w.mul(d,G));let F=w.mul(m,h);F=w.add(F,w.mul(p,S)),F=w.add(F,w.mul(p,G)),F=w.add(F,w.mul(f,S)),F=w.add(F,w.mul(f,G)),F=w.add(F,w.mul(d,_));let E=w.mul(f,_);E=w.add(E,w.mul(p,_)),E=w.add(E,w.mul(m,G)),E=w.add(E,w.mul(m,S));let B=w.mul(m,_);return u=v,c&&(u=w.add(u,w.mul(g[c],F)),u=w.add(u,w.mul(b[c],E)),u=w.add(u,w.mul(y[c],B))),[l,u]}L=x.slice(0,(3*u.domainSize+6)*p),R.T1=await K(x.slice(0,u.domainSize*p),"multiexp T1"),R.T2=await K(x.slice(u.domainSize*p,2*u.domainSize*p),"multiexp T2"),R.T3=await K(x.slice(2*u.domainSize*p,(3*u.domainSize+6)*p),"multiexp T3")}(),await async function(){const t=new r.BigBuffer(u.domainSize*p);await c.readToBuffer(t,0,u.domainSize*p,l[7][0].p);const a=new r.BigBuffer(u.domainSize*p);await c.readToBuffer(a,0,u.domainSize*p,l[8][0].p);const n=new r.BigBuffer(u.domainSize*p);await c.readToBuffer(n,0,u.domainSize*p,l[9][0].p);const i=new r.BigBuffer(u.domainSize*p);await c.readToBuffer(i,0,u.domainSize*p,l[10][0].p);const o=new r.BigBuffer(u.domainSize*p);await c.readToBuffer(o,0,u.domainSize*p,l[11][0].p);const s=new r.BigBuffer(u.domainSize*p);await c.readToBuffer(s,0,u.domainSize*p,l[12][0].p+10*u.domainSize*p);const d=new Uint8Array(2*f.F.n8*3);f.toRprUncompressed(d,0,R.T1),f.toRprUncompressed(d,2*f.F.n8,R.T2),f.toRprUncompressed(d,4*f.F.n8,R.T3),M.xi=H(d),e&&e.debug("xi: "+w.toString(M.xi));R.eval_a=j(B,M.xi),R.eval_b=j(x,M.xi),R.eval_c=j(A,M.xi),R.eval_s1=j(I,M.xi),R.eval_s2=j($,M.xi),R.eval_t=j(L,M.xi),R.eval_zw=j(U,w.mul(M.xi,w.w[u.power]));const m=w.mul(R.eval_a,R.eval_b);let g=R.eval_a;const h=w.mul(M.beta,M.xi);g=w.add(g,h),g=w.add(g,M.gamma);let b=R.eval_b;b=w.add(b,w.mul(h,u.k1)),b=w.add(b,M.gamma);let y=R.eval_c;y=w.add(y,w.mul(h,u.k2)),y=w.add(y,M.gamma);const G=w.mul(w.mul(w.mul(g,b),y),M.alpha);let S=R.eval_a;S=w.add(S,w.mul(M.beta,R.eval_s1)),S=w.add(S,M.gamma);let _=R.eval_b;_=w.add(_,w.mul(M.beta,R.eval_s2)),_=w.add(_,M.gamma);let v=w.mul(S,_);v=w.mul(v,M.beta),v=w.mul(v,R.eval_zw),v=w.mul(v,M.alpha),M.xim=M.xi;for(let e=0;e<u.power;e++)M.xim=w.mul(M.xim,M.xim);const F=w.div(w.sub(M.xim,w.one),w.mul(w.sub(M.xi,w.one),w.e(u.domainSize))),E=w.mul(F,w.mul(M.alpha,M.alpha)),k=v,C=w.add(G,E);z=new r.BigBuffer((u.domainSize+3)*p);for(let e=0;e<u.domainSize+3;e++){let r=w.mul(C,U.slice(e*p,(e+1)*p));e<u.domainSize&&(r=w.add(r,w.mul(m,t.slice(e*p,(e+1)*p))),r=w.add(r,w.mul(R.eval_a,a.slice(e*p,(e+1)*p))),r=w.add(r,w.mul(R.eval_b,n.slice(e*p,(e+1)*p))),r=w.add(r,w.mul(R.eval_c,i.slice(e*p,(e+1)*p))),r=w.add(r,o.slice(e*p,(e+1)*p)),r=w.sub(r,w.mul(k,s.slice(e*p,(e+1)*p)))),z.set(r,e*p)}R.eval_r=j(z,M.xi)}(),await async function(){const t=new Uint8Array(7*p);w.toRprBE(t,0,R.eval_a),w.toRprBE(t,p,R.eval_b),w.toRprBE(t,2*p,R.eval_c),w.toRprBE(t,3*p,R.eval_s1),w.toRprBE(t,4*p,R.eval_s2),w.toRprBE(t,5*p,R.eval_zw),w.toRprBE(t,6*p,R.eval_r),M.v=[],M.v[1]=H(t),e&&e.debug("v: "+w.toString(M.v[1]));for(let e=2;e<=6;e++)M.v[e]=w.mul(M.v[e-1],M.v[1]);let a=new r.BigBuffer((u.domainSize+6)*p);const n=w.mul(M.xim,M.xim);for(let e=0;e<u.domainSize+6;e++){let t=w.zero;t=w.add(t,w.mul(n,L.slice((2*u.domainSize+e)*p,(2*u.domainSize+e+1)*p))),e<u.domainSize+3&&(t=w.add(t,w.mul(M.v[1],z.slice(e*p,(e+1)*p)))),e<u.domainSize+2&&(t=w.add(t,w.mul(M.v[2],B.slice(e*p,(e+1)*p))),t=w.add(t,w.mul(M.v[3],x.slice(e*p,(e+1)*p))),t=w.add(t,w.mul(M.v[4],A.slice(e*p,(e+1)*p)))),e<u.domainSize&&(t=w.add(t,L.slice(e*p,(e+1)*p)),t=w.add(t,w.mul(M.xim,L.slice((u.domainSize+e)*p,(u.domainSize+e+1)*p))),t=w.add(t,w.mul(M.v[5],I.slice(e*p,(e+1)*p))),t=w.add(t,w.mul(M.v[6],$.slice(e*p,(e+1)*p)))),a.set(t,e*p)}let i=a.slice(0,p);i=w.sub(i,R.eval_t),i=w.sub(i,w.mul(M.v[1],R.eval_r)),i=w.sub(i,w.mul(M.v[2],R.eval_a)),i=w.sub(i,w.mul(M.v[3],R.eval_b)),i=w.sub(i,w.mul(M.v[4],R.eval_c)),i=w.sub(i,w.mul(M.v[5],R.eval_s1)),i=w.sub(i,w.mul(M.v[6],R.eval_s2)),a.set(i,0),a=N(a,M.xi),R.Wxi=await K(a,"multiexp Wxi");let o=new r.BigBuffer((u.domainSize+3)*p);for(let e=0;e<u.domainSize+3;e++){const t=U.slice(e*p,(e+1)*p);o.set(t,e*p)}i=o.slice(0,p),i=w.sub(i,R.eval_zw),o.set(i,0),o=N(o,w.mul(M.xi,w.w[u.power])),R.Wxiw=await K(o,"multiexp Wxiw")}(),R.protocol="plonk",R.curve=d.name,await c.close(),await n.close();let q=[];for(let i=1;i<=u.nPublic;i++){const t=m.slice(i*w.n8,i*w.n8+w.n8);q.push(r.Scalar.fromRprLE(t))}return R.A=f.toObject(R.A),R.B=f.toObject(R.B),R.C=f.toObject(R.C),R.Z=f.toObject(R.Z),R.T1=f.toObject(R.T1),R.T2=f.toObject(R.T2),R.T3=f.toObject(R.T3),R.eval_a=w.toObject(R.eval_a),R.eval_b=w.toObject(R.eval_b),R.eval_c=w.toObject(R.eval_c),R.eval_s1=w.toObject(R.eval_s1),R.eval_s2=w.toObject(R.eval_s2),R.eval_zw=w.toObject(R.eval_zw),R.eval_t=w.toObject(R.eval_t),R.eval_r=w.toObject(R.eval_r),R.Wxi=f.toObject(R.Wxi),R.Wxiw=f.toObject(R.Wxiw),delete R.eval_t,R=kt(R),q=kt(q),{proof:R,publicSignals:q};function P(t,a){const e=t.slice(a,a+4);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint32(0,!0)}function W(t){return t<u.nVars-u.nAdditions?m.slice(t*p,t*p+p):t<u.nVars?g.slice((t-(u.nVars-u.nAdditions))*p,(t-(u.nVars-u.nAdditions))*p+p):d.Fr.zero}function H(t){const a=r.Scalar.fromRprBE(new Uint8Array(Ct.arrayBuffer(t)));return w.e(a)}function j(t,a){const e=t.byteLength/p;if(0==e)return w.zero;let n=t.slice((e-1)*p,e*p);for(let i=e-2;i>=0;i--)n=w.add(w.mul(n,a),t.slice(i*p,(i+1)*p));return n}function N(t,a){const e=t.byteLength/p,n=new r.BigBuffer(e*p);n.set(w.zero,(e-1)*p),n.set(t.slice((e-1)*p,e*p),(e-2)*p);for(let i=e-3;i>=0;i--)n.set(w.add(t.slice((i+1)*p,(i+2)*p),w.mul(a,n.slice((i+1)*p,(i+2)*p))),i*p);if(!w.eq(t.slice(0,p),w.mul(w.neg(a),n.slice(0,p))))throw new Error("Polinomial does not divide");return n}async function K(t,a){const n=t.byteLength/p,i=T.slice(0,n*d.G1.F.n8*2),r=await d.Fr.batchFromMontgomery(t);let o=await d.G1.multiExpAffine(i,r,e,a);return o=d.G1.toAffine(o),o}async function D(t,a){a=a||[];let e=await w.ifft(t);const n=new r.BigBuffer(p*u.domainSize*4);n.set(e,0);const i=new r.BigBuffer(p*(u.domainSize+a.length));i.set(e,0);for(let r=0;r<a.length;r++)i.set(w.add(i.slice((u.domainSize+r)*p,(u.domainSize+r+1)*p),a[r]),(u.domainSize+r)*p),i.set(w.sub(i.slice(r*p,(r+1)*p),a[r]),r*p);return[i,await w.fft(n)]}}const{unstringifyBigInts:$t}=r.utils,{keccak256:Tt}=h.default;function Ot(t,a){const e=r.Scalar.fromRprBE(new Uint8Array(Tt.arrayBuffer(a)));return t.Fr.e(e)}function Mt(t){return("0"+t.toString(16)).slice(-2)}function qt(t){let a=t.toString(16);for(;a.length<64;)a="0"+a;return a=`"0x${a}"`,a}var Pt=Object.freeze({__proto__:null,setup:async function(t,a,e,n){await p.default.ready();const{fd:o,sections:s}=await i.readBinFile(a,"ptau",1,1<<22,1<<24),{curve:c,power:l}=await nt(o,s),{fd:d,sections:w}=await i.readBinFile(t,"r1cs",1,1<<22,1<<24),f=await u.readR1csHeader(d,w,!1),m=2*c.G1.F.n8,g=c.G1,h=2*c.G2.F.n8,b=c.Fr,y=c.Fr.n8;n&&n.info("Reading r1cs");let G=await i.readSection(d,w,2);const S=new Bt,_=new Bt;let v=f.nVars;const E=f.nOutputs+f.nPubInputs;await async function(){let t=0;function a(){const a=G.slice(t,t+4);t+=4;return new DataView(a.buffer).getUint32(0,!0)}function e(){const a=b.fromRprLE(G.slice(t,t+c.Fr.n8));return t+=c.Fr.n8,a}function i(){const t=[],n={k:c.Fr.zero},i=a();for(let r=0;r<i;r++){const i=a(),r=e();0==i?n.k=r:t.push([i,r])}const o=r(t);return n.s=o[0],n.coef=o[1],n}function r(t){if(0==t.length)return[0,c.Fr.zero];if(1==t.length)return t[0];const a=t.slice(0,t.length>>1),e=t.slice(t.length>>1),n=r(a),i=r(e),o=n[0],s=i[0],l=v++,u=c.Fr.zero,d=b.neg(n[1]),w=b.neg(i[1]),f=c.Fr.one,p=c.Fr.zero;return S.push([o,s,l,u,d,w,f,p]),_.push([o,s,n[1],i[1]]),[l,c.Fr.one]}for(let n=1;n<=E;n++){const t=n,a=0,e=0,i=c.Fr.zero,r=c.Fr.one,o=c.Fr.zero,s=c.Fr.zero,l=c.Fr.zero;S.push([t,a,e,i,r,o,s,l])}for(let o=0;o<f.nConstraints;o++){n&&o%1e4==0&&n.debug(`processing constraints: ${o}/${f.nConstraints}`);const t=i(),a=i(),e=i(),r=t.s,s=a.s,l=e.s,u=c.Fr.mul(t.coef,a.coef),d=c.Fr.mul(t.coef,a.k),w=c.Fr.mul(t.k,a.coef),p=c.Fr.neg(e.coef),m=c.Fr.sub(c.Fr.mul(t.k,a.k),e.k);S.push([r,s,l,u,d,w,p,m])}}();const B=await i.createBinFile(e,"zkey",1,14,1<<22,1<<24);if(f.prime!=c.r)return n&&n.error("r1cs curve does not match powers of tau ceremony curve"),-1;let x=F(S.length-1)+1;x<3&&(x=3);const A=2**x;if(n&&n.info("Plonk constraints: "+S.length),x>l)return n&&n.error(`circuit too big for this power of tau ceremony. ${S.length} > 2**${l}`),-1;if(!s[12])return n&&n.error("Powers of tau is not prepared."),-1;const U=new r.BigBuffer(A*m),L=s[12][0].p+(2**x-1)*m;await o.readToBuffer(U,0,A*m,L);const[z,R]=function(){let t=b.two;for(;e(t,[],x);)b.add(t,b.one);let a=b.add(t,b.one);for(;e(a,[t],x);)b.add(a,b.one);return[t,a];function e(t,a,e){const n=2**e;let i=b.one;for(let r=0;r<n;r++){if(b.eq(t,i))return!0;for(let e=0;e<a.length;e++)if(b.eq(t,b.mul(a[e],i)))return!0;i=b.mul(i,b.w[e])}return!1}}(),k={};await async function(t,a){await i.startWriteSection(B,t);const e=new Uint8Array(8+2*y),r=new DataView(e.buffer);for(let i=0;i<_.length;i++){const t=_[i];let o=0;r.setUint32(o,t[0],!0),o+=4,r.setUint32(o,t[1],!0),o+=4,e.set(t[2],o),o+=y,e.set(t[3],o),o+=y,await B.write(e),n&&i%1e6==0&&n.debug(`writing ${a}: ${i}/${_.length}`)}await i.endWriteSection(B)}(3,"Additions"),await I(4,0,"Amap"),await I(5,1,"Bmap"),await I(6,2,"Cmap"),await $(7,3,"Qm"),await $(8,4,"Ql"),await $(9,5,"Qr"),await $(10,6,"Qo"),await $(11,7,"Qc"),await async function(t,a){const e=new r.BigBuffer(y*A*3),o=new Bt(v),s=new Bt(v);let l=b.one;for(let i=0;i<A;i++)i<S.length?(f(S[i][0],i),f(S[i][1],A+i),f(S[i][2],2*A+i)):(f(0,i),f(0,A+i),f(0,2*A+i)),l=b.mul(l,b.w[x]),n&&i%1e6==0&&n.debug(`writing ${a} phase1: ${i}/${S.length}`);for(let i=0;i<v;i++){if("undefined"===typeof s[i])throw new Error("Variable not used");e.set(o[i],s[i]*y),n&&i%1e6==0&&n.debug(`writing ${a} phase2: ${i}/${v}`)}await i.startWriteSection(B,t);let u=e.slice(0,A*y);await T(u);let d=e.slice(A*y,A*y*2);await T(d);let w=e.slice(A*y*2,A*y*3);function f(t,a){let n;"undefined"===typeof o[t]?s[t]=a:e.set(o[t],a*y),n=a<A?l:a<2*A?b.mul(l,z):b.mul(l,R),o[t]=n}await T(w),await i.endWriteSection(B),u=await b.batchFromMontgomery(u),d=await b.batchFromMontgomery(d),w=await b.batchFromMontgomery(w),k.S1=await c.G1.multiExpAffine(U,u,n,"multiexp S1"),k.S2=await c.G1.multiExpAffine(U,d,n,"multiexp S2"),k.S3=await c.G1.multiExpAffine(U,w,n,"multiexp S3")}(12,"sigma"),await async function(t,a){await i.startWriteSection(B,t);const e=Math.max(E,1);for(let i=0;i<e;i++){let t=new r.BigBuffer(A*y);t.set(b.one,i*y),await T(t),n&&n.debug(`writing ${a} ${i}/${e}`)}await i.endWriteSection(B)}(13,"lagrange polynomials"),await i.startWriteSection(B,14);const C=new r.BigBuffer((A+6)*m);return await o.readToBuffer(C,0,(A+6)*m,s[2][0].p),await B.write(C),await i.endWriteSection(B),await async function(){await i.startWriteSection(B,1),await B.writeULE32(2),await i.endWriteSection(B),await i.startWriteSection(B,2);const t=c.q,a=8*(Math.floor((r.Scalar.bitLength(t)-1)/64)+1),e=c.r,n=8*(Math.floor((r.Scalar.bitLength(e)-1)/64)+1);let l;await B.writeULE32(a),await i.writeBigInt(B,t,a),await B.writeULE32(n),await i.writeBigInt(B,e,n),await B.writeULE32(v),await B.writeULE32(E),await B.writeULE32(A),await B.writeULE32(_.length),await B.writeULE32(S.length),await B.write(z),await B.write(R),await B.write(g.toAffine(k.Qm)),await B.write(g.toAffine(k.Ql)),await B.write(g.toAffine(k.Qr)),await B.write(g.toAffine(k.Qo)),await B.write(g.toAffine(k.Qc)),await B.write(g.toAffine(k.S1)),await B.write(g.toAffine(k.S2)),await B.write(g.toAffine(k.S3)),l=await o.read(h,s[3][0].p+h),await B.write(l),await i.endWriteSection(B)}(),await B.close(),await d.close(),await o.close(),void(n&&n.info("Setup Finished"));async function I(t,a,e){await i.startWriteSection(B,t);for(let i=0;i<S.length;i++)await B.writeULE32(S[i][a]),n&&i%1e6==0&&n.debug(`writing ${e}: ${i}/${S.length}`);await i.endWriteSection(B)}async function $(t,a,e){let o=new r.BigBuffer(A*y);for(let i=0;i<S.length;i++)o.set(S[i][a],i*y),n&&i%1e6==0&&n.debug(`writing ${e}: ${i}/${S.length}`);await i.startWriteSection(B,t),await T(o),await i.endWriteSection(B),o=await b.batchFromMontgomery(o),k[e]=await c.G1.multiExpAffine(U,o,n,"multiexp "+e)}async function T(t){const a=await b.ifft(t),e=new r.BigBuffer(A*y*4);e.set(a,0);const n=await b.fft(e);await B.write(a),await B.write(n)}},fullProve:async function(t,a,e,n){const i={type:"mem"};return await D(t,a,i),await It(e,i,n)},prove:It,verify:async function(t,a,e,n){t=$t(t),e=$t(e),a=$t(a);const i=await S(t.curve),r=i.Fr,o=i.G1;if(e=function(t,a){const e=t.G1,n=t.Fr,i={};return i.A=e.fromObject(a.A),i.B=e.fromObject(a.B),i.C=e.fromObject(a.C),i.Z=e.fromObject(a.Z),i.T1=e.fromObject(a.T1),i.T2=e.fromObject(a.T2),i.T3=e.fromObject(a.T3),i.eval_a=n.fromObject(a.eval_a),i.eval_b=n.fromObject(a.eval_b),i.eval_c=n.fromObject(a.eval_c),i.eval_zw=n.fromObject(a.eval_zw),i.eval_s1=n.fromObject(a.eval_s1),i.eval_s2=n.fromObject(a.eval_s2),i.eval_r=n.fromObject(a.eval_r),i.Wxi=e.fromObject(a.Wxi),i.Wxiw=e.fromObject(a.Wxiw),i}(i,e),t=function(t,a){const e=t.G1,n=t.G2,i=t.Fr,r=a;return r.Qm=e.fromObject(a.Qm),r.Ql=e.fromObject(a.Ql),r.Qr=e.fromObject(a.Qr),r.Qo=e.fromObject(a.Qo),r.Qc=e.fromObject(a.Qc),r.S1=e.fromObject(a.S1),r.S2=e.fromObject(a.S2),r.S3=e.fromObject(a.S3),r.k1=i.fromObject(a.k1),r.k2=i.fromObject(a.k2),r.X_2=n.fromObject(a.X_2),r}(i,t),!function(t,a){const e=t.G1;return!!e.isValid(a.A)&&(!!e.isValid(a.B)&&(!!e.isValid(a.C)&&(!!e.isValid(a.Z)&&(!!e.isValid(a.T1)&&(!!e.isValid(a.T2)&&(!!e.isValid(a.T3)&&(!!e.isValid(a.Wxi)&&!!e.isValid(a.Wxiw))))))))}(i,e))return n.error("Proof is not well constructed"),!1;const s=function(t,a){const e=t.G1,n=t.Fr,i=t.Fr.n8,r={},o=new Uint8Array(2*e.F.n8*3);e.toRprUncompressed(o,0,a.A),e.toRprUncompressed(o,2*e.F.n8,a.B),e.toRprUncompressed(o,4*e.F.n8,a.C),r.beta=Ot(t,o);const s=new Uint8Array(i);n.toRprBE(s,0,r.beta),r.gamma=Ot(t,s);const c=new Uint8Array(2*e.F.n8);e.toRprUncompressed(c,0,a.Z),r.alpha=Ot(t,c);const l=new Uint8Array(2*e.F.n8*3);e.toRprUncompressed(l,0,a.T1),e.toRprUncompressed(l,2*e.F.n8,a.T2),e.toRprUncompressed(l,4*e.F.n8,a.T3),r.xi=Ot(t,l);const u=new Uint8Array(7*i);n.toRprBE(u,0,a.eval_a),n.toRprBE(u,i,a.eval_b),n.toRprBE(u,2*i,a.eval_c),n.toRprBE(u,3*i,a.eval_s1),n.toRprBE(u,4*i,a.eval_s2),n.toRprBE(u,5*i,a.eval_zw),n.toRprBE(u,6*i,a.eval_r),r.v=[],r.v[1]=Ot(t,u);for(let w=2;w<=6;w++)r.v[w]=n.mul(r.v[w-1],r.v[1]);const d=new Uint8Array(2*e.F.n8*2);return e.toRprUncompressed(d,0,a.Wxi),e.toRprUncompressed(d,2*e.F.n8,a.Wxiw),r.u=Ot(t,d),r}(i,e);n&&(n.debug("beta: "+r.toString(s.beta,16)),n.debug("gamma: "+r.toString(s.gamma,16)),n.debug("alpha: "+r.toString(s.alpha,16)),n.debug("xi: "+r.toString(s.xi,16)),n.debug("v1: "+r.toString(s.v[1],16)),n.debug("v6: "+r.toString(s.v[6],16)),n.debug("u: "+r.toString(s.u,16)));const c=function(t,a,e){const n=t.Fr;let i=a.xi,r=1;for(let l=0;l<e.power;l++)i=n.square(i),r*=2;a.xin=i,a.zh=n.sub(i,n.one);const o=[],s=n.e(r);let c=n.one;for(let l=1;l<=Math.max(1,e.nPublic);l++)o[l]=n.div(n.mul(c,a.zh),n.mul(s,n.sub(a.xi,c))),c=n.mul(c,n.w[e.power]);return o}(i,s,t);if(n){n.debug("Lagrange Evaluations: ");for(let t=1;t<c.length;t++)n.debug(`L${t}(xi)=`+r.toString(c[t],16))}if(a.length!=t.nPublic)return n.error("Number of public signals does not match with vk"),!1;const l=function(t,a,e){const n=t.Fr;let i=n.zero;for(let r=0;r<a.length;r++){const t=n.e(a[r]);i=n.sub(i,n.mul(t,e[r+1]))}return i}(i,a,c);n&&n.debug("Pl: "+r.toString(l,16));const u=function(t,a,e,n,i){const r=t.Fr;let o=a.eval_r;o=r.add(o,n);let s=a.eval_a;s=r.add(s,r.mul(e.beta,a.eval_s1)),s=r.add(s,e.gamma);let c=a.eval_b;c=r.add(c,r.mul(e.beta,a.eval_s2)),c=r.add(c,e.gamma);let l=a.eval_c;l=r.add(l,e.gamma);let u=r.mul(r.mul(s,c),l);u=r.mul(u,a.eval_zw),u=r.mul(u,e.alpha),o=r.sub(o,u),o=r.sub(o,r.mul(i,r.square(e.alpha)));return r.div(o,e.zh)}(i,e,s,l,c[1]);n&&n.debug("t: "+r.toString(u,16));const d=function(t,a,e,n,i){const r=t.G1,o=t.Fr;let s=o.mul(o.mul(a.eval_a,a.eval_b),e.v[1]),c=r.timesFr(n.Qm,s),l=o.mul(a.eval_a,e.v[1]);c=r.add(c,r.timesFr(n.Ql,l));let u=o.mul(a.eval_b,e.v[1]);c=r.add(c,r.timesFr(n.Qr,u));let d=o.mul(a.eval_c,e.v[1]);c=r.add(c,r.timesFr(n.Qo,d)),c=r.add(c,r.timesFr(n.Qc,e.v[1]));const w=o.mul(e.beta,e.xi);let f=a.eval_a;f=o.add(f,w),f=o.add(f,e.gamma);let p=a.eval_b;p=o.add(p,o.mul(w,n.k1)),p=o.add(p,e.gamma);let m=a.eval_c;m=o.add(m,o.mul(w,n.k2)),m=o.add(m,e.gamma);let g=o.mul(o.mul(f,p),m);g=o.mul(g,o.mul(e.alpha,e.v[1]));let h=o.mul(o.mul(i,o.square(e.alpha)),e.v[1]);g=o.add(g,h),g=o.add(g,e.u),c=r.add(c,r.timesFr(a.Z,g));let b=a.eval_a;b=o.add(b,o.mul(e.beta,a.eval_s1)),b=o.add(b,e.gamma);let y=a.eval_b;y=o.add(y,o.mul(e.beta,a.eval_s2)),y=o.add(y,e.gamma);let G=o.mul(b,y);return G=o.mul(G,e.alpha),G=o.mul(G,e.v[1]),G=o.mul(G,e.beta),G=o.mul(G,a.eval_zw),c=r.sub(c,r.timesFr(n.S3,G)),c}(i,e,s,t,c[1]);n&&n.debug("D: "+o.toString(o.toAffine(d),16));const w=function(t,a,e,n,i){const r=t.G1,o=t.Fr;let s=a.T1;return s=r.add(s,r.timesFr(a.T2,e.xin)),s=r.add(s,r.timesFr(a.T3,o.square(e.xin))),s=r.add(s,i),s=r.add(s,r.timesFr(a.A,e.v[2])),s=r.add(s,r.timesFr(a.B,e.v[3])),s=r.add(s,r.timesFr(a.C,e.v[4])),s=r.add(s,r.timesFr(n.S1,e.v[5])),s=r.add(s,r.timesFr(n.S2,e.v[6])),s}(i,e,s,t,d);n&&n.debug("F: "+o.toString(o.toAffine(w),16));const f=function(t,a,e,n,i){const r=t.G1,o=t.Fr;let s=i;s=o.add(s,o.mul(e.v[1],a.eval_r)),s=o.add(s,o.mul(e.v[2],a.eval_a)),s=o.add(s,o.mul(e.v[3],a.eval_b)),s=o.add(s,o.mul(e.v[4],a.eval_c)),s=o.add(s,o.mul(e.v[5],a.eval_s1)),s=o.add(s,o.mul(e.v[6],a.eval_s2)),s=o.add(s,o.mul(e.u,a.eval_zw));return r.timesFr(r.one,s)}(i,e,s,0,u);n&&n.debug("E: "+o.toString(o.toAffine(f),16));const p=await async function(t,a,e,n,i,r){const o=t.G1,s=t.Fr;let c=a.Wxi;c=o.add(c,o.timesFr(a.Wxiw,e.u));let l=o.timesFr(a.Wxi,e.xi);const u=s.mul(s.mul(e.u,e.xi),s.w[n.power]);l=o.add(l,o.timesFr(a.Wxiw,u)),l=o.add(l,r),l=o.sub(l,i);return await t.pairingEq(o.neg(c),n.X_2,l,t.G2.one)}(i,e,s,t,f,w);return n&&(p?n.info("OK!"):n.warn("Invalid Proof")),p},exportSolidityCallData:async function(t,a){const e=await S(t.curve),n=e.G1,i=e.Fr;let r="";for(let s=0;s<a.length;s++)""!=r&&(r+=","),r+=qt(a[s]);const o=new Uint8Array(2*n.F.n8*9+7*i.n8);return n.toRprUncompressed(o,0,n.e(t.A)),n.toRprUncompressed(o,2*n.F.n8,n.e(t.B)),n.toRprUncompressed(o,4*n.F.n8,n.e(t.C)),n.toRprUncompressed(o,6*n.F.n8,n.e(t.Z)),n.toRprUncompressed(o,8*n.F.n8,n.e(t.T1)),n.toRprUncompressed(o,10*n.F.n8,n.e(t.T2)),n.toRprUncompressed(o,12*n.F.n8,n.e(t.T3)),n.toRprUncompressed(o,14*n.F.n8,n.e(t.Wxi)),n.toRprUncompressed(o,16*n.F.n8,n.e(t.Wxiw)),i.toRprBE(o,18*n.F.n8,i.e(t.eval_a)),i.toRprBE(o,18*n.F.n8+i.n8,i.e(t.eval_b)),i.toRprBE(o,18*n.F.n8+2*i.n8,i.e(t.eval_c)),i.toRprBE(o,18*n.F.n8+3*i.n8,i.e(t.eval_s1)),i.toRprBE(o,18*n.F.n8+4*i.n8,i.e(t.eval_s2)),i.toRprBE(o,18*n.F.n8+5*i.n8,i.e(t.eval_zw)),i.toRprBE(o,18*n.F.n8+6*i.n8,i.e(t.eval_r)),"0x"+Array.from(o).map(Mt).join("")+",["+r+"]"}});a.groth16=J,a.plonk=Pt,a.powersOfTau=gt,a.r1cs=Gt,a.wtns=_t,a.zKey=Rt}}]);